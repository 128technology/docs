(window.webpackJsonp=window.webpackJsonp||[]).push([[124],{183:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return u}));var r=n(2),a=n(6),i=(n(0),n(214)),o={title:"Learning VRF Routes",sidebar_label:"Learning VRF Routes"},s={unversionedId:"concepts_learning_VRF_routes",id:"concepts_learning_VRF_routes",isDocsHomePage:!1,title:"Learning VRF Routes",description:"128T uses the concept of Tenancy to provide L3 network segmentation. The 5.1 release brings support for learning VRF routes through BGP and the associated routing tables.",source:"@site/docs/concepts_learning_VRF_routes.md",slug:"/concepts_learning_VRF_routes",permalink:"/docs/concepts_learning_VRF_routes",version:"current",lastUpdatedAt:1616771788,sidebar_label:"Learning VRF Routes",sidebar:"docs",previous:{title:"Linux Host Networking Through 128T",permalink:"/docs/concepts_linux_host_networking"},next:{title:"Forwarding Plane Separation",permalink:"/docs/concepts_network_planes"}},c=[{value:"VRF Support",id:"vrf-support",children:[{value:"Static Routes",id:"static-routes",children:[]},{value:"Tenant to VRF Mapping",id:"tenant-to-vrf-mapping",children:[]},{value:"Subtenants",id:"subtenants",children:[]},{value:"Service Mapping",id:"service-mapping",children:[]}]}],l={rightToc:c};function u(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"128T uses the concept of Tenancy to provide L3 network segmentation. The 5.1 release brings support for learning VRF routes through BGP and the associated routing tables."),Object(i.b)("p",null,"Virtual Routing and Forwarding (VRF) instances make it possible to maintain multiple routing tables with overlapping address spaces in one router. A single 128T router can support multiple VRF instances, and is able to establish BGP peering sessions within each VRF to receive and distribute VRF routes. When a 128T router is connected to more than one VPN, each VPN can become its own VRF, supporting overlapping addresses. This provides a much broader scope of L3 network paths."),Object(i.b)("h2",{id:"vrf-support"},"VRF Support"),Object(i.b)("p",null,"To add VRF learning using BGP, add VRF objects to routing default-instance, and configure BGP as the routing protocol. This allows the 128T BGP instance to peer with a remote peer and learn routes for that particular VRF."),Object(i.b)("h3",{id:"static-routes"},"Static Routes"),Object(i.b)("p",null,"Static routes are configured in the respective VRF instance, using the ",Object(i.b)("inlineCode",{parentName:"p"},"static-route")," command. For configuration information, see ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/config_vrf_learning#vrf-support-for-static-routes"}),"VRF Support for Static Routes"),". "),Object(i.b)("p",null,"When VRF static routes are redistributed into BGP (using ",Object(i.b)("inlineCode",{parentName:"p"},"redistribute static"),"), only the static routes within that VRF are redistributed into BGP. When BGP is configured outside a VRF directly under ",Object(i.b)("inlineCode",{parentName:"p"},"routing default-instance"),", the static routes from the global (default) route table are distributed. The ",Object(i.b)("inlineCode",{parentName:"p"},"static-route")," command is used to populate static routes in the respective VRF table."),Object(i.b)("h3",{id:"tenant-to-vrf-mapping"},"Tenant to VRF Mapping"),Object(i.b)("p",null,"128T routers use Tenants to segment L3 traffic in the forwarding plane. VRF provides L3 segmentation at the routing layer. A set of routes associated with a VRF are accessible only to interfaces that have that particular VRF enabled. "),Object(i.b)("p",null,"A 128T router does not have any VRF definitions associated with an interface. Instead, an interface can be assigned a tenant to denote all traffic coming from that interface to be classified as that tenant. The default behavior of a 128T router is to allow all tenants to access the global routing table."),Object(i.b)("p",null,"VRFs are a table of routes that are accessed by tenants. The VRF-Tenant mapping is used for redistributing connected routes and for mapping services. A tenant can only be mapped to one VRF. "),Object(i.b)("h3",{id:"subtenants"},"Subtenants"),Object(i.b)("p",null,"When a tenant is mapped to a VRF, all the subtenants are mapped to that VRF. If a particular subtenant is already mapped to another VRF, that VRF takes precedence for the subtenant. "),Object(i.b)("h3",{id:"service-mapping"},"Service Mapping"),Object(i.b)("p",null,"Service definitions remain the same, with prefixes/FQDN and access policies allowing specific tenants to access those services. Each Service prefix is matched against the routing table that corresponds to the tenant (using the VRF ",Object(i.b)("inlineCode",{parentName:"p"},"tenant-name")," mapping configuration). If no VRF tenant mapping exists for the tenant, the service prefix is matched against the global routing table. If no match is found, no FIB entries are installed for that service and tenant."),Object(i.b)("p",null,"For information about configuring each of the following types of Service Mapping, please refer to the linked configuration procedure."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(r.a)({parentName:"li"},{href:"/docs/config_vrf_learning#services-with-different-tenants"}),"Services with Different Tenants")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(r.a)({parentName:"li"},{href:"/docs/config_vrf_learning#single-service-with-multiple-tenants-associated-with-different-vrfs"}),"Single Service with multiple tenants associated with different VRFs")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(r.a)({parentName:"li"},{href:"/docs/config_vrf_learning#service-with-no-tenant-vrf-association"}),"Service with no tenant VRF association"))))}u.isMDXComponent=!0},214:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return f}));var r=n(0),a=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=a.a.createContext({}),u=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=u(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},b=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=u(n),b=r,f=p["".concat(o,".").concat(b)]||p[b]||d[b]||i;return n?a.a.createElement(f,s(s({ref:t},l),{},{components:n})):a.a.createElement(f,s({ref:t},l))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=b;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);