"use strict";(self.webpackChunk_128t_docs=self.webpackChunk_128t_docs||[]).push([[6575],{45549:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var t=i(74848),o=i(28453);const a={title:"High Availability - Theory of Operation",sidebar_label:"HA - Theory of Operation"},r=void 0,s={id:"concepts_ha_theoryofoperation",title:"High Availability - Theory of Operation",description:"This document describes the most common set of deployment models for taking two instances of SSR routing software (referred to as \u201cnodes\u201d) and deploying those nodes together to provide high availability. The SSR routing software presents several deployment options for high availability, including:",source:"@site/docs/concepts_ha_theoryofoperation.md",sourceDirName:".",slug:"/concepts_ha_theoryofoperation",permalink:"/docs/concepts_ha_theoryofoperation",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1710958440,formattedLastUpdatedAt:"Mar 20, 2024",frontMatter:{title:"High Availability - Theory of Operation",sidebar_label:"HA - Theory of Operation"},sidebar:"docs",previous:{title:"Ethernet Over Secure Vector Routing",permalink:"/docs/concepts_EthOverSVR"},next:{title:"Interface Types",permalink:"/docs/concepts_interface_types"}},c={},l=[{value:"Intended Audience",id:"intended-audience",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Theory of Operation",id:"theory-of-operation",level:2},{value:"Dual Node High Availability",id:"dual-node-high-availability",level:3},{value:"Redundancy Link",id:"redundancy-link",level:4},{value:"About State Synchronization",id:"about-state-synchronization",level:4},{value:"Leader Election",id:"leader-election",level:4},{value:"Dual Router High Availability",id:"dual-router-high-availability",level:3},{value:"Terminology",id:"terminology",level:2},{value:"Modeling",id:"modeling",level:2},{value:"Active/Standby Model",id:"activestandby-model",level:3},{value:"Active/Standby Model with Fabric Interface",id:"activestandby-model-with-fabric-interface",level:3},{value:"Active/Active Model",id:"activeactive-model",level:3},{value:"Active/Active with no Shared Interfaces",id:"activeactive-with-no-shared-interfaces",level:4},{value:"Hybrid Models",id:"hybrid-models",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"This document describes the most common set of deployment models for taking two instances of SSR routing software (referred to as \u201cnodes\u201d) and deploying those nodes together to provide high availability. The SSR routing software presents several deployment options for high availability, including:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dual node high availability"}),': where two nodes form one logical router, with shared state and a "fabric" backplane between them.']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dual router high availability"}),": where two nodes form two logical routers, with no shared state. This is a familiar approach to administrators accustomed to deploying pairs of legacy routing platforms."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This document will describe the benefits and caveats of each of these models, as well as delving into other architectural decisions that should be considered when deploying highly available systems."}),"\n",(0,t.jsx)(n.h2,{id:"intended-audience",children:"Intended Audience"}),"\n",(0,t.jsx)(n.p,{children:"This document is intended for network architects, and is to be used as a guideline during the network design phase of deployment."}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"High availability (or \u201cHA\u201d) is the practice of deploying additional network elements for traffic resiliency, to account for link or system downtime. In general, we encourage the deployment of highly available routers and conductors, as this will provide service continuity in the event of network failures, software faults, or hardware downtime (both scheduled and unscheduled)."}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"There are other types of protection afforded SSR-powered networks, including path protection (via peer path selection) and link impairment protection (via session resiliency features, packet duplication, packet retransmitions, etc.), but these are not a consequence of supplying two nodes to mitigate the impact of failures."})}),"\n",(0,t.jsx)(n.p,{children:"This document will define the terms used to describe the SSR\u2019s implementation of high availability, describe the various configurable elements associated with high availability, and how they can be set and/or tuned in order to afford maximal protection against failures. It also presents various common topologies, to assist in selecting the best model for any given deployment."}),"\n",(0,t.jsx)(n.p,{children:"In general, the configurations presented in this document will be presented in a \u201cvanilla\u201d fashion \u2013 without undue service configuration, tenant configuration, traffic policies, etc. \u2013 except where necessary to illustrate specific use cases relevant to high availability behavior."}),"\n",(0,t.jsx)(n.h2,{id:"theory-of-operation",children:"Theory of Operation"}),"\n",(0,t.jsx)(n.p,{children:"Deploying a highly available solution offers protection from failures or maintenance operations that could impact service. Generally speaking, the protections that high availability offers can be grouped in to several categories:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Software protection"}),": the software components on a node can stop (due to upgrade, software fault, reboot, etc.) the companion components on a highly available counterpart can resume operation."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Hardware protection"}),": the platform on which the software runs can stop (due to replacement, hardware failure, power failure, etc.) while the companion highly available platform assumes control of all shared interfaces. Note that for the purposes of this document, Virtual Machines (VM) will be treated as hardware components unless specifically called out otherwise."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Link protection"}),": a single link can fail and not interrupt service, if there are shared forwarding interfaces and/or fabric interfaces (more on this later)."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The SSR offers all three types of protections listed above in each of its HA models. It does so by deploying two nodes that operate in concert (as either one logical router or as two logical routers) to provide service continuity in the event of failure. Each of the nodes contains a full set of software processes necessary for forwarding traffic, running routing protocols, communicating with its peers and management systems, etc. This allows an SSR to run independently in the event that its HA counterpart is unavailable."}),"\n",(0,t.jsx)(n.h3,{id:"dual-node-high-availability",children:"Dual Node High Availability"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.em,{children:"dual node high availability"})," design is a longstanding deployment model supported by the SSR. In this design two nodes share one common set of state; because the SSR is stateful (i.e., it retains some residual information about each active session for the lifetime of that session) it must share this information with its counterpart to protect active sessions in the event of any impairment. This model is exemplified by using a ",(0,t.jsx)(n.em,{children:"redundancy link"}),", a dedicated connection between the two systems where session state is exchanged."]}),"\n",(0,t.jsx)(n.h4,{id:"redundancy-link",children:"Redundancy Link"}),"\n",(0,t.jsxs)(n.p,{children:["Configured within the SSR software (and implemented as a ",(0,t.jsx)(n.em,{children:"team interface"}),' in Linux), this is typically implemented as a cross connect cable between two colocated systems. The "cross connect cable" is a logical concept and also includes connections between virtual machines. Also, the cross connect cable may be implemented between geographically diverse locations.']}),"\n",(0,t.jsxs)(n.p,{children:["For more information about configuring redundant interfaces see ",(0,t.jsx)(n.a,{href:"/docs/config_non_forwarding_ha_interfaces",children:"Non-forwarding HA Interfaces"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["the SSR configuration model only supports one redundancy link to be configured. However, it is possible to configure a second redundancy link manually. For instructions, refer to the guide ",(0,t.jsx)(n.a,{href:"/docs/config_adding_interfaces_to_ha_team",children:"Adding Interfaces to HA Team Interface"})," for configuring additional redundancy links."]}),"\n",(0,t.jsx)(n.h4,{id:"about-state-synchronization",children:"About State Synchronization"}),"\n",(0,t.jsx)(n.p,{children:"This state sharing occurs via a high-performance database that is available to both nodes. As sessions are established through an SSR node, the receiving node consults this database to determine whether this session had previously been established via its counterpart. If it does not find any information, it processes this session as new, and it inserts state information into the shared database. In this way, session continuity is preserved irrespective of which node is active at the outset of an established session."}),"\n",(0,t.jsx)(n.p,{children:"For SSR routers, session state synchronization for a session will occur only after a number of packets have been exchanged bi-directionally. This is to avoid the overhead of state synchronization for short-lived sessions (fewer than twelve packets), where a client reinitiating the session anew is as efficient as recovery."}),"\n",(0,t.jsx)(n.p,{children:"Conductors also leverage the redundancy link for state synchronization, to checkpoint the status of connected systems, configuration updates, and alarms."}),"\n",(0,t.jsx)(n.h4,{id:"leader-election",children:"Leader Election"}),"\n",(0,t.jsxs)(n.p,{children:["In addition to state synchronization, the SSR software also uses the redundancy link for ",(0,t.jsx)(n.em,{children:"leader election"}),' \u2013 the term used to describe the negotiation between the two systems for determining which is more fit for active duty. Because the SSR software is comprised of a number of discrete software processes (daemons), there are actually multiple "leaders" for each dual node HA system simultaneously. Below is the sample output of the command ',(0,t.jsx)(n.code,{children:"show system processes node all"})," from a highly available system:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"admin@BEACON00128A.BEACON00128# show sys proc node all\nFri 2020-02-28 10:47:26 UTC\n\n============== ============================= ========= ========= =======\n Node           Process                       Status    Primary   Role\n============== ============================= ========= ========= =======\n BEACON00128A   accessManager                 running             combo\n BEACON00128A   analyticsReporter             running             combo\n BEACON00128A   applicationFrameworkManager   running             combo\n BEACON00128A   conflux                       running             combo\n BEACON00128A   databaseQueryCoordinator      running             combo\n BEACON00128A   dynamicPeerUpdateManager      running   N         combo\n BEACON00128A   fastLane                      running             combo\n BEACON00128A   highwayManager                running             combo\n BEACON00128A   nodeMonitor                   running             combo\n BEACON00128A   persistentDataManager         running             combo\n BEACON00128A   redisServerManager            running   N         combo\n BEACON00128A   routingManager                running   Y         combo\n BEACON00128A   secureCommunicationManager    running             combo\n BEACON00128A   securityKeyManager            running   N         combo\n BEACON00128A   snmpTrapAgent                 running             combo\n BEACON00128A   stateMonitor                  running             combo\n BEACON00128A   systemServicesCoordinator     running             combo\n BEACON00128B   accessManager                 running             combo\n BEACON00128B   analyticsReporter             running             combo\n BEACON00128B   applicationFrameworkManager   running             combo\n BEACON00128B   conflux                       running             combo\n BEACON00128B   databaseQueryCoordinator      running             combo\n BEACON00128B   dynamicPeerUpdateManager      running   Y         combo\n BEACON00128B   fastLane                      running             combo\n BEACON00128B   highwayManager                running             combo\n BEACON00128B   nodeMonitor                   running             combo\n BEACON00128B   persistentDataManager         running             combo\n BEACON00128B   redisServerManager            running   Y         combo\n BEACON00128B   routingManager                running   N         combo\n BEACON00128B   secureCommunicationManager    running             combo\n BEACON00128B   securityKeyManager            running   Y         combo\n BEACON00128B   snmpTrapAgent                 running             combo\n BEACON00128B   stateMonitor                  running             combo\n BEACON00128B   systemServicesCoordinator     running             combo\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This is a list of the system processes that make up an SSR. (There is a similar, but different set that exists on an SSR conductor.) The fourth column in the output shows whether a process is primary (has leadership) or not. As you can see in this output, it is not unusual for one node to be leader for some processes and not others; for example, ",(0,t.jsx)(n.code,{children:"BEACON00128A"})," is the leader for ",(0,t.jsx)(n.code,{children:"routingManager"}),", whereas ",(0,t.jsx)(n.code,{children:"BEACON00128B"})," is the leader for ",(0,t.jsx)(n.code,{children:"securityKeyManager"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Each of the processes indicated with a ",(0,t.jsx)(n.code,{children:"Y"})," or ",(0,t.jsx)(n.code,{children:"N"})," undergo leader election and remain in constant communication with one another, whereas the processes that do not have any indicator will run on both systems autonomously. Failure events will oftentimes re-trigger a leader election process to ensure the fittest system is in control."]}),"\n",(0,t.jsx)(n.h3,{id:"dual-router-high-availability",children:"Dual Router High Availability"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.em,{children:"dual router high availability"}),' design is where two individual SSR software instances are coupled together to provide continuity in the event of a failure. While there is no state synchronized between the two devices (since there is no redundancy link), they are redundant to one another by upstream SSR devices detecting a failure and routing around it. Note that "detecting a failure" entails routing protocol convergence and/or SVR path failure determination.']}),"\n",(0,t.jsx)(n.p,{children:"The dual router high availability design has some distinct advantages over the dual node design:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Fewer port requirements."}),"\n",(0,t.jsx)(n.li,{children:"Fewer moving parts. Because there is no dependency on synchronizing a shared database, electing leaders between paired nodes, or sharing state, the implementation is more resilient."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"It does come with some tradeoffs, however:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"More rigid restrictions on the network topology (IGP/EGP)."}),"\n",(0,t.jsx)(n.li,{children:"Certain SSR features are not usable and/or must be disabled, notably source NAT and TCP state enforcement."}),"\n",(0,t.jsx)(n.li,{children:"Shared interfaces cannot be used."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"terminology",children:"Terminology"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Dual Node High Availability"}),": a deployment model where two instances (nodes) of SSR software are coupled as a single, logical router."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Dual Router High Availability"}),": a deployment model where two instances (nodes) of SSR software are coupled as distinct, single node routers."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Fabric link"}),': a connection between two nodes in a dual node high availability deployment. This link is used for forwarding traffic between the two nodes, analogous to a backplane "fabric" on a chassis-based router. This is also sometimes referred to as an ',(0,t.jsx)(n.em,{children:"inter-node link"}),' or a "dogleg."']}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Inter-router link"}),": a connection between two routers in a dual router high availability deployment. This link is used for forwarding traffic between the two routers much in the same way as a fabric link does between nodes. Generally we run iBGP as an IGP over this inter-router link."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Redundancy link"}),": a connection between two nodes in a dual node high availability deployment, used exclusively for synchronizing state between them. (No traffic is forwarded on this link.)"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Redundancy group"}),": a configuration construct for combining interfaces into a collection that ",(0,t.jsx)(n.em,{children:"shares fate"}),', such that if one interface goes down, the other interface(s) in the group are administratively failed over along with it. This is useful in deployments where two nodes are configured as mirror images of one another in an "active/standby" configuration.']}),"\n",(0,t.jsx)(n.h2,{id:"modeling",children:"Modeling"}),"\n",(0,t.jsxs)(n.p,{children:["In general terms, high availability is an expense incurred to guard against failure scenarios; typically, high availability models are ",(0,t.jsx)(n.em,{children:"not"})," intended to protect against all possible failure scenarios, but the most common ones (e.g., software failure, hardware failure, circuit failure). It is impractical, and in some cases impossible, to guard against multiple concurrent failures. Thus, a tolerance profile should be constructed to include the failure scenarios that are most common, most impactful, or both."]}),"\n",(0,t.jsx)(n.p,{children:"When deploying a high availability SSR router, there are several options available depending on (Ethernet) port availability, and the tolerance profile. The two main considerations when designing a high availability SSR are interface failure protections and platform protections (inclusive of hardware and software)."}),"\n",(0,t.jsx)(n.p,{children:"Interface protections allow for service continuity when an interface fails, or is otherwise disabled. Each interface that is to be protected has presence on both nodes in an HA couplet, which will have ramifications on the hardware platform that is selected. In a simple example, two nodes each have a single LAN and WAN interface, and these are protected. Adding a second WAN provider will incur an additional Ethernet interface on one node, but protecting it requires an additional Ethernet interface on its counterpart. Alternatively, you could deploy two independent WAN connections on each node (e.g., ISP 1 and ISP 2 on one node, ISP 3 and ISP 4 on the other node) and consume the same number of ports, but without any specific protection around any interface or ISP failure."}),"\n",(0,t.jsx)(n.p,{children:"While the SSR platform affords you many flexibilities in your modeling, let's start with some simple assumptions and build upon them."}),"\n",(0,t.jsx)(n.h3,{id:"activestandby-model",children:"Active/Standby Model"}),"\n",(0,t.jsxs)(n.p,{children:["The simplest model is the active/standby model, where both nodes are configured as mirror images of one another. The LAN and WAN interfaces are protected, and there is a redundancy link between the two nodes to synchronize state. In this model, you will need to configure a set of ",(0,t.jsx)(n.code,{children:"redundancy-group"})," configurations, one for each node."]}),"\n",(0,t.jsx)(n.p,{children:"This configuration protects against a LAN interface failure, a WAN interface failure, and a platform failure."}),"\n",(0,t.jsx)(n.h3,{id:"activestandby-model-with-fabric-interface",children:"Active/Standby Model with Fabric Interface"}),"\n",(0,t.jsx)(n.p,{children:"This model builds upon the previous by adding a fabric interface. The fabric interface between the nodes gives them a path to reach the active LAN or WAN interface, should packets arrive that need forwarding but the local LAN/WAN interface is unusable."}),"\n",(0,t.jsxs)(n.p,{children:["In the Active/Standby Model with Fabric Interface, the ",(0,t.jsx)(n.code,{children:"redundancy-group"})," configuration is no longer mandatory; it can be used to govern administrative preference over which node in a pair is active when all interfaces are usable across the router. A ",(0,t.jsx)(n.code,{children:"redundancy-group"})," can also be used to put both LAN and WAN traffic on a single node when there is only one interface impaired, but this is strictly administrative preference."]}),"\n",(0,t.jsx)(n.p,{children:"This model is advantaged over the standard active/standby model, in that it protects against the failure mode where dissimilar links are down on each system (e.g., the LAN interface on node 1 is down and the WAN interface on node 2 is down). This comes at the cost of one additional Ethernet port on each node, to account for the fabric link."}),"\n",(0,t.jsx)(n.h3,{id:"activeactive-model",children:"Active/Active Model"}),"\n",(0,t.jsx)(n.p,{children:"The Active/Active model is one where each node in the router has (at least) one unique interface per node that is not represented on its counterpart. Generally speaking, this model has a protected LAN interface and dissimilar WAN interfaces (e.g., node 1 uses ISP 1, node 2 uses ISP 2). Just as with the Active/Standby model, you can elect to add a fabric interface \u2013 and in fact it is quite common to do so. (Without a fabric interface, only one ISP can be used at a time and it is arguably equivalent to an Active/Standby model.) With a fabric interface in place, the router will use the appropriate egress ISP based on the policies provisioned in the SSR, assuming all ISPs are active, which may mean that traffic arrives on one node and egresses via a separate node."}),"\n",(0,t.jsx)(n.p,{children:'This model is advantaged over Active/Standby in that you get the benefit of "SD-WAN," able to leverage the best ISP path for a given type of traffic at any point in time. Yet if any platform failure occurs, each node has the ability to continue processing traffic to the array of ISPs available to it.'}),"\n",(0,t.jsx)(n.h4,{id:"activeactive-with-no-shared-interfaces",children:"Active/Active with no Shared Interfaces"}),"\n",(0,t.jsx)(n.p,{children:"There are certain features which may be unavailable when not using shared interfaces, including:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"source-nat"})," \u2013 when there's no shared interface, there's no way to synchronize dynamically allocated source ports."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"transport-state-enforcement"})," \u2013\xa0this feature will not work without synchronizing data between systems."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"hybrid-models",children:"Hybrid Models"}),"\n",(0,t.jsxs)(n.p,{children:["Hybrid models include multiple LAN interfaces and multiple WAN interfaces, some or all of which may be protected. (These deployments may include ",(0,t.jsx)(n.code,{children:"redundancy-group"})," configurations, to ensure the coupled interfaces are always co-active on the same node.) Hybrid models should include a fabric interface between the nodes."]}),"\n",(0,t.jsx)(n.p,{children:"This model is used when there are multiple LAN interfaces, and one or more need protection. It requires the maximum number of Ethernet interfaces, and is the most complex configuration model."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>s});var t=i(96540);const o={},a=t.createContext(o);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);