"use strict";(self.webpackChunk_128t_docs=self.webpackChunk_128t_docs||[]).push([[602],{43974:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var r=n(74848),i=n(28453);const a={title:"Ethernet Over Secure Vector Routing",sidebar_label:"Ethernet Over Secure Vector Routing"},o=void 0,s={id:"concepts_EthOverSVR",title:"Ethernet Over Secure Vector Routing",description:"Ethernet Over SVR (EoSVR) extends the Ethernet broadcast domain across multiple sites. EoSVR provides a site to site ethernet broadcast domain between SSR routers with increased security and efficiency, without the overhead of IP packet encapsulation.",source:"@site/docs/concepts_EthOverSVR.md",sourceDirName:".",slug:"/concepts_EthOverSVR",permalink:"/docs/concepts_EthOverSVR",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Ethernet Over Secure Vector Routing",sidebar_label:"Ethernet Over Secure Vector Routing"},sidebar:"docs",previous:{title:"Application Discovery",permalink:"/docs/concepts_application_discovery"},next:{title:"HA - Theory of Operation",permalink:"/docs/concepts_ha_theoryofoperation"}},c={},d=[{value:"Packet Types",id:"packet-types",level:2},{value:"Non-IP, Multicast and broadcast Traffic",id:"non-ip-multicast-and-broadcast-traffic",level:3},{value:"Tunneling",id:"tunneling",level:4},{value:"IP Traffic",id:"ip-traffic",level:3},{value:"VxLAN Traffic",id:"vxlan-traffic",level:3},{value:"Ethernet Over Secure Vector Routing across a NAT boundary",id:"ethernet-over-secure-vector-routing-across-a-nat-boundary",level:3}];function l(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"Ethernet Over SVR (EoSVR) extends the Ethernet broadcast domain across multiple sites. EoSVR provides a site to site ethernet broadcast domain between SSR routers with increased security and efficiency, without the overhead of IP packet encapsulation."}),"\n",(0,r.jsx)(t.p,{children:"Layer 2 and IP traffic destined for your LAN arrives on the SSR and is transported over an Ethernet Over SVR bridge to the destination SSR within the customer network. The bridge is configured between not more than two routers, and the configuration is validated before committing it to the running config."}),"\n",(0,r.jsx)(t.p,{children:"EoSVR is only supported for point to point layer 2 services, and provides the following advantages over traditional MPLS networks:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Eliminates additional CE routers needed to deploy MPLS pseudowires."}),"\n",(0,r.jsx)(t.li,{children:"First packet processing with metadata for VxLAN packets eliminates the need to tunnel the VxLAN packet within another IP packet (e.g. GRE)."}),"\n",(0,r.jsx)(t.li,{children:"SVR packets can travel over multiple transport types (Internet or MPLS), providing multipath failover redundancy."}),"\n",(0,r.jsx)(t.li,{children:"Increased security; SVR packets are encrypted and authenticated."}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/docs/config_EthoSVR",children:"Configuring Ethernet over SVR"})," for configuration information."]}),"\n",(0,r.jsx)(t.h2,{id:"packet-types",children:"Packet Types"}),"\n",(0,r.jsx)(t.p,{children:"There are four types of packets that are enabled for Ethernet Over SVR:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Non-IP, multicast, and broadcast packets."}),"\n",(0,r.jsx)(t.li,{children:"IP packets."}),"\n",(0,r.jsx)(t.li,{children:"VxLAN packets carrying Non-IP packets."}),"\n",(0,r.jsx)(t.li,{children:"VxLAN packets carrying IP packets."}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"non-ip-multicast-and-broadcast-traffic",children:"Non-IP, Multicast and broadcast Traffic"}),"\n",(0,r.jsx)(t.p,{children:"Non-IP (ARP, CDP, LLDP, etc), multicast, and broadcast traffic are encapsulated within an IP payload and transported as an SVR packet. Once marked as EoSVR, the flow is given a high timeout, allowing the flow to be reused for all non-IP packets.\nAll SVR capabilities are available for non-IP encapsulated packets including failover, service policy enforcement, and multi-hop. EoSVR is backward compatible with all existing routers, and can be enabled on a per end point basis."}),"\n",(0,r.jsx)(t.p,{children:"Each router with an EoSVR bridge auto generates a new, specific service and service-route for EoSVR traffic, allowing remote routers with the same bridge name to access the EoSVR bridge. When the bridge name is manually specified, a new service-route is introduced."}),"\n",(0,r.jsx)(t.p,{children:"Non-IP traffic is unidirectional. For example, router R1 and router R2 have the same bridge name configured. An ARP request on EoSVR bridge on router R1 creates a session to R2 via SVR. The ARP reply from R2 creates another session to R1. These sessions will timeout if no other non-IP packets are detected."}),"\n",(0,r.jsx)(t.h4,{id:"tunneling",children:"Tunneling"}),"\n",(0,r.jsx)(t.p,{children:"There is an option to encapsulate and tunnel all traffic if necessary. In this case, even the IP traffic will be tunneled under the session. Q-in-Q traffic is treated as non-ip traffic and uses the same session."}),"\n",(0,r.jsx)(t.h3,{id:"ip-traffic",children:"IP Traffic"}),"\n",(0,r.jsx)(t.p,{children:"All IP traffic is sent over SVR with the following new fields in the metadata:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Source MAC"}),"\n",(0,r.jsx)(t.li,{children:"Destination MAC"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"The first packet carries the metadata containing the L2 information to the final SSR. There the ethernet header is replaced with the fields above, and the packet is sent to the final destination."}),"\n",(0,r.jsx)(t.p,{children:"The new metadata field avoids tunneling the entire IP packet inside another IP packet. The first packet carries the layer 2 information. Any subsequent packets that are sent without metadata have the layer 2 information restored at the final SSR, which extends the broadcast domain."}),"\n",(0,r.jsx)(t.p,{children:"Flows setup for IP Traffic are bidirectional. These packets are expected to be in the same broadcast domain, and the ethernet address is preserved at the final SSR."}),"\n",(0,r.jsx)(t.h3,{id:"vxlan-traffic",children:"VxLAN Traffic"}),"\n",(0,r.jsx)(t.p,{children:"VxLAN traffic is is identified by having a destination port of 4789. When VxLAN traffic arrives on an SSR, a service is defined to carry the traffic. This service will have a service-route with a next-hop to the peer SSR. Because VxLAN traffic is unidirectional, two services are used to transport VxLAN traffic from one SSR to another, one in each direction."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"SSR R1 Service"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"Service Vxlan_To_R2\n  protocol UDP\n  Port 4789\n  Address 1.1.1.0/24\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"SSR R2 Service"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"Service Vxlan_To_R1\n  protocol UDP\n  Port 4789\n  Address 2.2.2.0/24\n"})}),"\n",(0,r.jsx)(t.p,{children:"If more addresses are involved, they are added to the existing service. All VxLAN traffic is sent over SVR with new fields in ebedded in the metadata."}),"\n",(0,r.jsx)(t.h3,{id:"ethernet-over-secure-vector-routing-across-a-nat-boundary",children:"Ethernet Over Secure Vector Routing across a NAT boundary"}),"\n",(0,r.jsxs)(t.p,{children:["Due to differences in the nature of EoSVR versus regular SVR, standard methods for ",(0,r.jsx)(t.a,{href:"/docs/config_session_recovery#session-recovery-detection",children:"Session Recovery Detection"})," and prevention may not function as well for EoSVR traffic. In scenarios where a spoke router needs to sit behind a NAT in relation to the hub, it is recommended to set the NAT device to 1:1 NAT to the SSR, rather than implementing NAPT."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>s});var r=n(96540);const i={},a=r.createContext(i);function o(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);