"use strict";(self.webpackChunk_128t_docs=self.webpackChunk_128t_docs||[]).push([[5503],{18224:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var s=i(74848),t=i(28453);const o={title:"Application Identification",sidebar_label:"Application Identification"},a=void 0,r={id:"concepts_appid",title:"Application Identification",description:"Identifying Applications by Name",source:"@site/docs/concepts_appid.md",sourceDirName:".",slug:"/concepts_appid",permalink:"/docs/concepts_appid",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1710958440,formattedLastUpdatedAt:"Mar 20, 2024",frontMatter:{title:"Application Identification",sidebar_label:"Application Identification"},sidebar:"docs",previous:{title:"Transport Based Encryption",permalink:"/docs/config_transport_encryption"},next:{title:"Application Learning Mode",permalink:"/docs/config_app_ident"}},c={},d=[{value:"Identifying Applications by Name",id:"identifying-applications-by-name",level:2},{value:"DNS-based Services",id:"dns-based-services",level:3},{value:"AppID based on TLS",id:"appid-based-on-tls",level:3},{value:"AppID and Tenancy",id:"appid-and-tenancy",level:3},{value:"AppID using Modules",id:"appid-using-modules",level:3},{value:"Script-Based Module Setup",id:"script-based-module-setup",level:4},{value:"Systemd-Based Module Setup",id:"systemd-based-module-setup",level:4},{value:"Viewing Modules",id:"viewing-modules",level:4},{value:"Referencing Modules in Configuration",id:"referencing-modules-in-configuration",level:4}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"identifying-applications-by-name",children:"Identifying Applications by Name"}),"\n",(0,s.jsx)(n.p,{children:'The Session Smart Routing platform has several techniques by which it can associate inbound traffic to named applications. This is sometimes referred to as "Application Identification" (or "appID"), and the feature that allows administrators to define network policies using Fully Qualified Domain Names (FQDNs) instead of IP addresses.'}),"\n",(0,s.jsx)(n.p,{children:"The SSR has three built-in techniques for affiliating named applications to services, all of which will be described in this document. (A fourth technique, involving service function chaining third party software is not covered here.) The three techniques are:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Using DNS to resolve FQDNs to IP addresses"}),"\n",(0,s.jsxs)(n.li,{children:["Using the ",(0,s.jsx)(n.code,{children:"application-identification"})," mode ",(0,s.jsx)(n.code,{children:"tls"})]}),"\n",(0,s.jsxs)(n.li,{children:["Using the ",(0,s.jsx)(n.code,{children:"application-identification"})," mode ",(0,s.jsx)(n.code,{children:"module"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Additionally, ",(0,s.jsx)(n.a,{href:"/docs/config_domain-based_web_filter#overview",children:"Web Filtering"})," provides domain classification using third party data sources to generate a comprehensive, real time, and up-to-date worldwide database for categorizing domains and URLs."]}),"\n",(0,s.jsx)(n.h3,{id:"dns-based-services",children:"DNS-based Services"}),"\n",(0,s.jsxs)(n.p,{children:["Generally, when configuring a ",(0,s.jsx)(n.code,{children:"service"})," on a SSR, administrators use the ",(0,s.jsx)(n.code,{children:"address"})," field to identify the IP address(es)/CIDR block(s) that the SSR should use to match to inbound traffic. However, the ",(0,s.jsx)(n.code,{children:"address"})," field will also accept hostnames, such as ",(0,s.jsx)(n.code,{children:"www.128technology.com"}),". When a service uses a hostname in the ",(0,s.jsx)(n.code,{children:"address"})," field, it is referred to as a ",(0,s.jsx)(n.em,{children:"DNS-based service"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For every DNS-based service, the SSR will use the host system's local DNS capabilities to resolve hostnames; for every IP address that is returned the SSR will treat that as though it were configured in the ",(0,s.jsx)(n.code,{children:"address"})," field, and install FIB entries accordingly. It will also refresh these FIB entries based on the time-to-live (TTL) returned by the DNS server. Here is a sample configuration for reference:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"admin@labsystem1.fiedler# show config running authority service interchange\n\nconfig\n\n    authority\n\n        service  interchange\n            name                  interchange\n\n            scope                 private\n            security              internal\n            address               community.128technology.com\n\n            access-policy         trusted\n                source      trusted\n                permission  allow\n            exit\n            share-service-routes  false\n        exit\n    exit\nexit\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this configuration, the ",(0,s.jsx)(n.code,{children:"address"})," is configured as ",(0,s.jsx)(n.code,{children:"community.128technology.com"}),". This will be resolved once the configuration is committed, and the SSR will resolve that hostname and install FIB entries. The SSR will periodically re-resolve those hostnames to ensure that the FIB entries are kept up-to-date."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["The names used in the ",(0,s.jsx)(n.code,{children:"address"})," field must be DNS-resolvable names. You cannot use wildcards such as ",(0,s.jsx)(n.code,{children:"*.128technology.com"}),"."]})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"This is a very easy and intuitive way to associate traffic to services, without having to define a long list of IP addresses. When upstream devices change their IP address, there's no need to reconfigure the SSR to keep it up-to-date, as this is handled by DNS."}),"\n",(0,s.jsx)(n.li,{children:'Unlike AppID based on TLS, there is no "chicken and egg issue;" i.e., no prerequisite to have the destination be reachable in order to learn the destination\'s name.'}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Disadvantages"}),":"]}),"\n",(0,s.jsxs)(n.p,{children:["This technique relies on your SSR getting the same answers from DNS that your clients get. Take for example a massive SaaS provider such as ",(0,s.jsx)(n.code,{children:"www.salesforce.com"}),". Their web site resolves to hundreds or thousands of IP addresses distributed across the globe. When the SSR resolves that hostname, it will get a handful of answers; if a client does the same DNS query and gets a different set of answers, then the traffic the client sends will not match the FIB entries that the SSR has created."]}),"\n",(0,s.jsx)(n.admonition,{title:"Key to success",type:"tip",children:(0,s.jsx)(n.p,{children:"Use DNS-based services when your destination uses a small set of non-volatile IP addresses. This technique is perfect for small, hosted services. The effectiveness of using DNS-based services diminishes rapidly when referencing names that resolve to dozens of address or more."})}),"\n",(0,s.jsx)(n.h3,{id:"appid-based-on-tls",children:"AppID based on TLS"}),"\n",(0,s.jsxs)(n.p,{children:["The SSR can also ",(0,s.jsx)(n.em,{children:"learn about named destinations"})," by inspecting the traffic that traverses it. This is done by inspecting the client hello TLS message sent by a client during the TLS handshake process. Importantly: ",(0,s.jsx)(n.em,{children:"this presupposes that the SSR can route packets to that destination for the  purposes of retrieving the clients's message"}),". Thus, when using AppID based on TLS, it is important to ensure that there is a ",(0,s.jsx)(n.code,{children:"service"})," and ",(0,s.jsx)(n.code,{children:"service-route"})," capable of reaching that server in addition to the one you'll configure for the named application."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:['Normally this is done by having a "catch-all" service for ',(0,s.jsx)(n.code,{children:"0.0.0.0/0"})," to route traffic out to the internet, but it does not need to be. Please refer to ",(0,s.jsx)(n.a,{href:"/docs/config_domain-based_web_filter#configuring-web-filtering-using-the-pcli",children:(0,s.jsx)(n.strong,{children:"Configuring Web Filtering using the PCLI"})})," for detailed configuration steps."]})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Client Hello"})," message typically includes a ",(0,s.jsx)(n.code,{children:"server_name"})," extension, which represents the domain-name being accessed by the client. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-console",metastring:"{15-18}",children:"TLSv1.3 Record Layer: Handshake Protocol: Client Hello\n    Content Type: Handshake (22)\n    Version: TLS 1.0 (0x0301)\n    Length: 562\n    Handshake Protocol: Client Hello\n        Handshake Type: Client Hello (1)\n        Length: 558\n        Version: TLS 1.2 (0x0303)\n        Random: a625da0d64ec96bbf35a2422a5a10816812e978b7f90db592e50be120c0fa9a4\n        Cipher Suites Length: 32\n        Cipher Suites (16 suites)\n        Compression Methods Length: 1\n        Compression Methods (1 method)\n        Extensions Length: 453\n        Extension: server_name (len=20) name=www.example.com\n            Type: server_name (0)\n            Length: 20\n            Server Name Indication extension\n        Extension: compress_certificate (len=3)\n        Extension: application_settings (len=5)\n        Extension: psk_key_exchange_modes (len=2)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"server_name"})," extension shown above with the value ",(0,s.jsx)(n.code,{children:"www.example.com"})," represents the domain in this example. This is what SSR will parse and subsequently retain as the domain-name for this destination. Domain-names and IP addresses are learned from TLS and mapped to hierarchical services using the ",(0,s.jsx)(n.code,{children:"domain-name"})," field."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'config\n\n    authority\n\n        service  internet\n            name                  internet\n            description           "all internet traffic"\n            address               0.0.0.0/0\n\n            access-policy         trusted\n                source      trusted\n                permission  allow\n            exit\n            service-policy        NO-LTE\n            share-service-routes  false\n        exit\n\n        service  example.internet\n            name                  example.internet\n            description           "www.example.com website"\n            domain-name           www.example.com\n\n            access-policy         trusted\n                source      trusted\n                permission  deny\n            exit\n            share-service-routes  false\n        exit\n    exit\nexit\n'})}),"\n",(0,s.jsx)(n.h3,{id:"appid-and-tenancy",children:"AppID and Tenancy"}),"\n",(0,s.jsx)(n.p,{children:"Application Identification service lookups now consider the source tenant. This allows matches to be specific to certain networks/users. For example, the following configuration will now properly classify by tenancy:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"service internet\n   address 0.0.0.0/0\n   access-policy tenant1 allow\n   access-policy tenant2 allow\n\nservice app1.internet\n   application-name WorkApp\n   access-policy tenant1 allow\n\nservice app2.internet\n   application-name WorkApp\n   access-policy tenant2 allow\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Traffic learned for WorkApp using ",(0,s.jsx)(n.code,{children:"tenant1"})," will match to ",(0,s.jsx)(n.code,{children:"app1.internet"}),", whereas that using ",(0,s.jsx)(n.code,{children:"tenant2"})," will match to ",(0,s.jsx)(n.code,{children:"app2.internet"}),". This is true for all types of AppId services."]}),"\n",(0,s.jsx)(n.p,{children:"Additionally, AppId child services no longer merge in access-policy entries from the parent service if an access-policy is provisioned on the AppId child. If no access-policy is provisioned, then the parent's policies are inherited."}),"\n",(0,s.jsx)(n.h3,{id:"appid-using-modules",children:"AppID using Modules"}),"\n",(0,s.jsxs)(n.p,{children:["The last, and arguably most powerful built-in technique for performing application identification is to use a ",(0,s.jsx)(n.em,{children:"module"})," \u2013 effectively, a script that is resident on the SSR's host operating system that will generate a JSON file that contains dynamic, ingestible routes. This is extremely flexible, but requires some programming expertise."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"It is also possible to simply place a static JSON document on the SSR's filesystem (i.e., one that is not generated by a local script) as a means of feeding an application identification module into the SSR)."})}),"\n",(0,s.jsx)(n.p,{children:"Configuring application identification based on modules first requires that a router have the feature enabled:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"admin@labsystem1.fiedler# show config running authority router becket application-identification\n\nconfig\n\n    authority\n\n        router  becket\n            name    becket\n\n            application-identification\n                mode  module\n            exit\n        exit\n    exit\nexit\n"})}),"\n",(0,s.jsx)(n.h4,{id:"script-based-module-setup",children:"Script-Based Module Setup"}),"\n",(0,s.jsxs)(n.p,{children:["Scripts are placed on the router's filesystem at ",(0,s.jsx)(n.code,{children:"/etc/128technology/application-modules/"}),". These scripts produce a JSON output stored at ",(0,s.jsx)(n.code,{children:"/var/run/128technology/application-modules/"}),", which in turn is processed by the SSR and installed as FIB entries."]}),"\n",(0,s.jsx)(n.h4,{id:"systemd-based-module-setup",children:"Systemd-Based Module Setup"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"systemd"})," may be used to manage the execution of application identification modules. JSON output produced by the module is passed directly to the highway REST API instead of being written to disk."]}),"\n",(0,s.jsxs)(n.p,{children:["Using this approach, modules are registered by creating a file at ",(0,s.jsx)(n.code,{children:"/etc/128technology/application-modules/services/<module-name>"}),". This file lists the systemd units of the module and specifies if and how SSR should interact with them."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"reload-service"}),": When the highway process starts, reload the systemd unit. This is a signal to POST the JSON to highway again as module data is not saved through process restarts."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"stop-on-shutdown"}),": Stop the systemd unit when SSR is shutting down."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Modules must be registered in order for SSR to accept the POST of JSON module data."}),"\n",(0,s.jsx)(n.p,{children:"In the following example, a systemd timer unit is used to periodically invoke the main service/script, which does the work of gathering module data. Both are stopped on shutdown, but only the timer unit needs to fire again on restart of SSR."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'[\n    {\n        "service-name": "office365.timer",\n        "reload-service": true,\n        "stop-on-shutdown": true\n    },\n    {\n        "service-name": "office365.service",\n        "reload-service": false,\n        "stop-on-shutdown": true\n    }\n]\n'})}),"\n",(0,s.jsxs)(n.p,{children:["For more information about using timers with the systemd service, refer to ",(0,s.jsx)(n.a,{href:"https://wiki.archlinux.org/title/Systemd/Timers",children:"ArchLinux systemd/Timers"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"viewing-modules",children:"Viewing Modules"}),"\n",(0,s.jsxs)(n.p,{children:["Module registration and detailed module status (including a full list of ip-prefix/ports/protocol) can be accessed via a REST API or from the CLI. Please refer to the API documentation available from the GUI, and the ",(0,s.jsx)(n.a,{href:"/docs/cli_reference#show-application-modules-status",children:(0,s.jsx)(n.code,{children:"show application modules status"})})," and ",(0,s.jsx)(n.a,{href:"/docs/cli_reference#show-application-modules-registration",children:(0,s.jsx)(n.code,{children:"show application modules registration"})})," for full details."]}),"\n",(0,s.jsx)(n.h4,{id:"referencing-modules-in-configuration",children:"Referencing Modules in Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["Each module produces a list of service names that are used to reference it in the configuration through the ",(0,s.jsx)(n.code,{children:"application-name"})," list. For example, an application identification module named ",(0,s.jsx)(n.code,{children:"zoom"})," will retrieve and process all of the IP addresses used for the ",(0,s.jsx)(n.code,{children:"ZOOM"})," videoconferencing service. The corresponding service looks like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'admin@labsystem1.fiedler# show config running authority service ZOOM\n\nconfig\n\n    authority\n\n        service  ZOOM\n            name                  ZOOM\n\n            description           "Zoom meetings"\n            scope                 private\n            application-name      ZOOM\n\n            access-policy         trusted\n                source      trusted\n                permission  allow\n            exit\n            share-service-routes  false\n        exit\n    exit\nexit\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"application-name"})," is configured as it is with the ",(0,s.jsx)(n.code,{children:"tls"})," variant of ",(0,s.jsx)(n.code,{children:"application-identification"}),". In this case, however, it will read the contents of a JSON file to produce the FIB entries. Below is an excerpt from the ",(0,s.jsx)(n.code,{children:"zoom"})," module's output:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n  "duration": 86400,\n  "services": {\n    "ZOOM": [\n      {\n        "ip-prefix": "3.7.35.0/25"\n      },\n      {\n        "ip-prefix": "3.21.137.128/25"\n      },\n      {\n        "ip-prefix": "3.22.11.0/24"\n      },\n      ...\n    ]\n  },\n  "module-name": "zoom"\n}\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["In the case of this module, the script that generates the JSON is ",(0,s.jsx)(n.code,{children:"/etc/128technology/application-modules/zoom.py"}),", the output is stored as ",(0,s.jsx)(n.code,{children:"/var/run/128technology/application-modules/zoom.json"}),". A copy of the ",(0,s.jsx)(n.code,{children:"zoom.py"})," script is available on our user community, ",(0,s.jsx)(n.a,{href:"https://community.juniper.net/answers/communities/community-home?CommunityKey=310d1a41-12fa-4627-9a99-880145a7c87c",children:"AI-Driven SD-WAN powered by Session Smart community"}),"."]})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"services"})," tag of ",(0,s.jsx)(n.code,{children:"ZOOM"})," is what associates these IP prefixes to the service we've shown above. Each of these IP prefixes (which could have also included port ranges, but don't in this example) will create a FIB entry for the ",(0,s.jsx)(n.code,{children:"ZOOM"})," service, and be given access and policy determinations based on the configuration we've set in our SSR."]}),"\n",(0,s.jsxs)(n.p,{children:["The SSR ships with an Office365 module, and other modules can be found on ",(0,s.jsx)(n.a,{href:"https://community.juniper.net/answers/communities/community-home?CommunityKey=310d1a41-12fa-4627-9a99-880145a7c87c",children:"AI-Driven SD-WAN powered by Session Smart community"}),", our user community, as well as on Github. For more information on writing your own application identification module, refer to our developer documentation or our sample code."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>r});var s=i(96540);const t={},o=s.createContext(t);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);