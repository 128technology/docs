"use strict";(self.webpackChunk_128t_docs=self.webpackChunk_128t_docs||[]).push([[6661],{95492:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var i=t(74848),r=t(28453);const o={title:"Glossary"},a="Data Model",s={id:"concepts_glossary",title:"Glossary",description:"The data model used to describe network, service, and policy behavior consists of a series of interrelated objects, organized into a configuration hierarchy. All of these modeling components are contained within the authority, which represents the collection of all SSRs networking components.",source:"@site/docs/concepts_glossary.md",sourceDirName:".",slug:"/concepts_glossary",permalink:"/docs/concepts_glossary",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1710452559,formattedLastUpdatedAt:"Mar 14, 2024",frontMatter:{title:"Glossary"},sidebar:"docs",previous:{title:"Waypoints",permalink:"/docs/concepts_waypoint_ports"},next:{title:"Overview",permalink:"/docs/wan_overview"}},c={},d=[{value:"Authority",id:"authority",level:2},{value:"Network Layer",id:"network-layer",level:2},{value:"Router",id:"router",level:3},{value:"Node",id:"node",level:3},{value:"Device Interface",id:"device-interface",level:3},{value:"Network Interface",id:"network-interface",level:3},{value:"Redundancy Group",id:"redundancy-group",level:2},{value:"Neighborhoods",id:"neighborhoods",level:2},{value:"Adjacency",id:"adjacency",level:2},{value:"Peer",id:"peer",level:2},{value:"Tenants",id:"tenants",level:2},{value:"Service Layer",id:"service-layer",level:2},{value:"Services",id:"services",level:3},{value:"Policy Layer",id:"policy-layer",level:2},{value:"Service Policies",id:"service-policies",level:2},{value:"Vectors",id:"vectors",level:2},{value:"Service Routes",id:"service-routes",level:2},{value:"Service Route Policies",id:"service-route-policies",level:2},{value:"Routing Default-Instance",id:"routing-default-instance",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"data-model",children:"Data Model"}),"\n",(0,i.jsxs)(n.p,{children:["The data model used to describe network, service, and policy behavior consists of a series of interrelated objects, organized into a configuration hierarchy. All of these modeling components are contained within the ",(0,i.jsx)(n.em,{children:"authority"}),", which represents the collection of all SSRs networking components."]}),"\n",(0,i.jsx)(n.h2,{id:"authority",children:"Authority"}),"\n",(0,i.jsx)(n.p,{children:"The topmost configuration container in the SSR data model is called the authority, which is where system-wide global data is stored. Conceptually, the authority represents the complete set of all SSRs managed under a single organizational entity. The global data within the authority container includes service-layer and policy-layer configuration that applies to all of the SSRs within this organizational entity. (In this document, the term \u201cauthority\u201d and \u201corganizational entity\u201d are synonymous, unless specifically referring to the SSR\u2019s configuration object container.)"}),"\n",(0,i.jsx)(n.h2,{id:"network-layer",children:"Network Layer"}),"\n",(0,i.jsx)(n.h3,{id:"router",children:"Router"}),"\n",(0,i.jsxs)(n.p,{children:["The routers are the SSR software systems responsible for receiving and sending packets to their correct destinations, aka routing. Routers consist of either one node (a standalone router), or two nodes (a high availability router).  You can think of Routers as a logical entity because they consist of one or two Nodes. Routers have ",(0,i.jsx)(n.code,{children:"description"})," and ",(0,i.jsx)(n.code,{children:"location-coordinates"})," fields that should be used to help give you some context as to the function of this router and where it is located. The name given to a Router should be a helpful name that tells the viewer of the configuration as much useful information as possible."]}),"\n",(0,i.jsx)(n.p,{children:"Any elements configured under the Router are considered Local Data. That means that they only exist in that Router and not in the other Routers. Global Data is anything that is configured outside the Router element and applies to your whole Authority, not just one Router."}),"\n",(0,i.jsx)(n.h3,{id:"node",children:"Node"}),"\n",(0,i.jsx)(n.p,{children:"Included in the local data of the router hierarchy are the software components that comprise that router referred to as nodes. Each node is a single running instance of SSRs software that is either physical or virtual. Within router-specific routing attributes \u2013 including both \u201cclassic\u201d routing protocols such as BGP and OSPF, as well as SSRs-specific \u201cservice routes,\u201d defined elsewhere. Localized policies, primarily focused on the traffic distribution and traffic engineering behaviors of an individual router, are also part of the local data within the router hierarchy."}),"\n",(0,i.jsx)(n.h3,{id:"device-interface",children:"Device Interface"}),"\n",(0,i.jsxs)(n.p,{children:["The Device Interface tells you which port on the physical server that you are using. The Device Interface will consist of a name, the type of interface it is, and an identifier for how to tell the SSR software which port it is taking control of. For example, if the ",(0,i.jsx)(n.code,{children:"type"})," is ",(0,i.jsx)(n.code,{children:"ethernet"}),", then you will need to put in a ",(0,i.jsx)(n.code,{children:"pci-address"})," as your identifier."]}),"\n",(0,i.jsxs)(n.p,{children:["A device interface (represented in the data model as ",(0,i.jsx)(n.em,{children:"device-interface"}),") is the manifestation of the I/O device where packets ingress and egress. A device-interface can be one of several varieties:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Ethernet"}),": the most common type of interface, this is a physical Ethernet port on a hardware-based system, or a virtual Ethernet port on a virtual machine."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Host"}),": creates a Kernel Network Interface, which carries traffic between the SSR software application and the underlying host operating system."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bridged"}),": used to attach the SSR software application to a Linux bridge."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PPPoE"}),": support for Point-to-Point Protocol over Ethernet, a popular network delivery mechanism for ISPs when using DSL."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"LTE"}),": support for Long-Term Evolution, a standard wireless communication protocol developed by the 3GPP."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"T1"}),": support for Transmission System 1, a carrier interface with speeds up to 1.544Mbps."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"device-interface  wan1\n    name                 wan1\n    pci-address          0000:00:09.0\n    shared-phys-address  00:01:00:A1:CA:A5\n    \n    network-interface    wan1\n        name                   wan1\n        global-id              5\n    \n        neighborhood           internet\n            name      internet\n            topology  hub\n            vector    internet\n        exit\n        inter-router-security  aes1\n    \n        address                3.3.3.128\n            ip-address     3.3.3.128\n            prefix-length  24\n            gateway        3.3.3.1\n        exit\n    \n        adjacency              1.1.1.128\n            ip-address             1.1.1.128\n            peer-connectivity      bidirectional\n            peer                   seattlesite1\n            generated              true\n            inter-router-security  aes1\n            cost                   0\n            qp-value               0\n            vector                 internet\n        exit\n    \n        adjacency              2.2.2.128\n            ip-address             2.2.2.128\n            peer-connectivity      bidirectional\n            peer                   dallassite1\n            generated              true\n            inter-router-security  aes1\n            cost                   0\n            qp-value               0\n            vector                 internet\n        exit\n    exit\nexit\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If two Device Interfaces have the same ",(0,i.jsx)(n.code,{children:"shared-phys-address"})," that means that they are a redundant pair. You can issue ",(0,i.jsx)(n.code,{children:"show device-interface summary"})," to find out which one is currently active and which is standby."]}),"\n",(0,i.jsx)(n.h3,{id:"network-interface",children:"Network Interface"}),"\n",(0,i.jsxs)(n.p,{children:["Network Interfaces tell your SSRs which networks it is participating in. You can have multiple Network Interfaces per Device Interface. Network Interfaces have ",(0,i.jsx)(n.code,{children:"global-id"})," that are used by the SSR software to identify which Network Interface to send traffic out of. If two Network Interfaces have the same ",(0,i.jsx)(n.code,{children:"global-id"})," then they are treated as redundant for one another, or as a ",(0,i.jsx)(n.em,{children:"shared interface"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["Do not assign a ",(0,i.jsx)(n.code,{children:"global-id"})," to a network-interface on your own. Your SSRs will generate a unique ",(0,i.jsx)(n.code,{children:"global-id"})," for a standalone network-interface, and will automatically assign a common ",(0,i.jsx)(n.code,{children:"global-id"})," for shared interfaces when it detects that they each reference a common ",(0,i.jsx)(n.code,{children:"shared-phys-address"}),". For more information on shared interfaces, refer to the ",(0,i.jsx)(n.a,{href:"/docs/concepts_ha_theoryofoperation",children:"High Availability Best Practices"})," documentation."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"network-interface    wan1\n    name                   wan1\n    global-id              5\n    \n    neighborhood           internet\n        name      internet\n        topology  hub\n        vector    internet\n    exit\n    inter-router-security  aes1\n    \n    address                3.3.3.128\n        ip-address     3.3.3.128\n        prefix-length  24\n        gateway        3.3.3.1\n    exit\n    \n    adjacency              1.1.1.128\n        ip-address             1.1.1.128\n        peer-connectivity      bidirectional\n        peer                   seattlesite1\n        generated              true\n        inter-router-security  aes1\n        cost                   0\n        qp-value               0\n        vector                 internet\n    exit\n    \n    adjacency              2.2.2.128\n        ip-address             2.2.2.128\n        peer-connectivity      bidirectional\n        peer                   dallassite1\n        generated              true\n        inter-router-security  aes1\n        cost                   0\n        qp-value               0\n        vector                 internet\n    exit\nexit\n"})}),"\n",(0,i.jsx)(n.h2,{id:"redundancy-group",children:"Redundancy Group"}),"\n",(0,i.jsx)(n.p,{children:"A Reundancy Group is a group of Device Interfaces that are tied to each other. This means that when one goes down, they will all switch over to their redundant partner."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"redundancy-group      datacenter1\n    name      datacenter1\n    \n    member    datacenter1 mpls1\n        node       datacenter1\n        device-id  mpls1\n    exit\n    \n    member    datacenter1 srv1\n        node       datacenter1\n        device-id  srv1\n    exit\n    \n    member    datacenter1 srv2\n        node       datacenter1\n        device-id  srv2\n    exit\n    \n    member    datacenter1 srv3\n        node       datacenter1\n        device-id  srv3\n    exit\n    \n    member    datacenter1 wan1\n        node       datacenter1\n        device-id  wan1\n    exit\nexit\n"})}),"\n",(0,i.jsx)(n.h2,{id:"neighborhoods",children:"Neighborhoods"}),"\n",(0,i.jsxs)(n.p,{children:["Neighborhoods are a means of specifying which Network Interfaces in your SSRs Authority are connected to each other, helping your SSRs conductor understand your network topology. By using Neighborhoods, your SSRs will auto-configure certain elements, such as Peers, Adjacencies, and Service Routes, to ensure that the Network Interfaces in the same Neighborhood connect to each other automatically. By viewing the Network Interfaces and seeing which ones share the same Neighborhood labels, you can get a picture for which Network Interfaces are connected to each other. In the Neighborhood configuration, you can also see a field called ",(0,i.jsx)(n.code,{children:"topology"}),". The values for Topology are:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"mesh"}),"\n",(0,i.jsx)(n.li,{children:"hub"}),"\n",(0,i.jsx)(n.li,{children:"spoke"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Meshes will connect to everything, hubs connect to spokes and meshes, and spokes connect to hubs and meshes. Knowing this information can help you visualize which Network Interfaces are connected to each other."}),"\n",(0,i.jsx)(n.h2,{id:"adjacency",children:"Adjacency"}),"\n",(0,i.jsx)(n.p,{children:"Another sub-element of the Network Interface is the Adjacency. The Adjacency tells your SSRs how it can reach its Peer. Peers can be reachable from multiple Network Interfaces, so this is just one of the ways that a particular Peer is reachable."}),"\n",(0,i.jsx)(n.h2,{id:"peer",children:"Peer"}),"\n",(0,i.jsx)(n.p,{children:"A Peer is another SSRs router that your current SSRs router is connected to. By understanding which routers are Peers, you can start to draw out a network diagram with your SSRs nodes."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"router          seattlesite1\n    name                  seattlesite1\n    location-coordinates  +47.6062-122.3321/\n    description           Test-Changed\n    inter-node-security   internal\n    \n    peer                  bostonsite1\n        name            bostonsite1\n        authority-name  CompanyX\n        router-name     bostonsite1\n    exit\n    \n    node                  branchoffice1\n        name              branchoffice1\n        asset-id          branch-1-router\n        role              combo\n    \n        device-interface  mpls1\n            name               mpls1\n            type               ethernet\n            pci-address        0000:00:04.0\n            capture-filter     len>0\n    \n            network-interface  mpls1\n                name                    mpls1\n                global-id               3\n                vlan                    0\n                type                    external\n                conductor               false\n    \n                neighborhood            mpls\n                    name                mpls\n                    peer-connectivity   bidirectional\n                    topology            spoke\n                    vector              mpls\n                    qp-value            0\n    \n                    udp-transform\n                        mode                 auto-detect\n                        detect-interval      300\n                        nat-keep-alive-mode  disabled\n                    exit\n    \n                    path-mtu-discovery\n                        enabled   false\n                        interval  600\n                    exit\n                exit\n                inter-router-security   internal\n                prioritization-mode     local\n                source-nat              false\n                qp-value                0\n                mtu                     1500\n                enforced-mss            disabled\n    \n                address                 10.0.128.0\n                    ip-address     10.0.128.0\n                    prefix-length  31\n                    gateway        10.0.128.1\n                exit\n    \n                adjacency               10.0.128.1\n                    ip-address             10.0.128.1\n                    peer-connectivity      bidirectional\n                    peer                   bostonsite1\n                    generated              true\n                    inter-router-security  aes1\n                    cost                   0\n                    qp-value               0\n                    vector                 mpls\n    \n                    udp-transform\n                        mode                 auto-detect\n                        detect-interval      300\n                        nat-keep-alive-mode  disabled\n                    exit\n    \n                    path-mtu-discovery\n                        enabled   false\n                        interval  600\n                    exit\n                exit\n                icmp                    allow\n                    multicast-listeners     automatic\n                    multicast-report-proxy  false\n                    dhcp                    disabled\n                exit\n            exit\n    \n            device-interface  lan1\n                name               lan1\n                pci-address        0000:00:03.0\n    \n                network-interface  lan1\n                    name       lan1\n                    global-id  4\n                    tenant     seattle.corp\n    \n                    address    192.168.64.1\n                        ip-address     192.168.64.1\n                        prefix-length  24\n                    exit\n                exit\n            exit\n    \n            device-interface  wan1\n                name               wan1\n                pci-address        0000:00:05.0\n    \n                network-interface  wan1\n                    name                   wan1\n                    global-id              6\n    \n                    neighborhood           internet\n                        name    internet\n                        vector  internet\n                    exit\n                    inter-router-security  aes1\n    \n                    address                1.1.1.128\n                        ip-address     1.1.1.128\n                        prefix-length  24\n                        gateway        1.1.1.1\n                    exit\n    \n                    adjacency              3.3.3.128\n                        ip-address             3.3.3.128\n                        peer-connectivity      bidirectional\n                        peer                   bostonsite1\n                        generated              true\n                        inter-router-security  aes1\n                        cost                   0\n                        qp-value               0\n                        vector                 internet\n                    exit\n                exit\n            exit\n        exit\n    exit\nexit\n"})}),"\n",(0,i.jsx)(n.h2,{id:"tenants",children:"Tenants"}),"\n",(0,i.jsx)(n.p,{children:"Tenant is the term within the SSR data model used to represent a segmented partition within a L2/L3 network. Unlike other networking paradigms, where segmentation is done using overlay networking techniques (such as VLANs, VxLANs, etc.), the SSR uses a novel tenancy model to place traffic sources and routes to their services (also referred to as service routes) into logical partitions within the underlay network itself. A rich set of hierarchical access control policies built into the tenancy model ensures that network traffic flows along prescribed paths, and only from eligible sources. Tenants, like the services that they access, reside within the global data in an authority's configuration. A tenant defined within the SSR authority is said to \u201cstretch\u201d across all SSRs that are members of that authority, and tenant information is shared between SSRs router instances."}),"\n",(0,i.jsxs)(n.p,{children:["For information on how to define tenants, read the section in our documentation ",(0,i.jsx)(n.a,{href:"/docs/config_tenants",children:"Configuring Tenants"})]}),"\n",(0,i.jsx)(n.p,{children:"Tenants are a way to define endpoints that you want to identify on your network. When you define Tenants, you can create access policies on your Services based on the Tenant name."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'tenant          corp\n    name  corp\nexit\n    \ntenant          seattle.corp\n    name  seattle.corp\nexit\n    \ntenant          dallas.corp\n    name  dallas.corp\nexit\n    \ntenant          _internal_\n    name         _internal_\n    description  "Auto generated tenant for internal services"\n    generated    true\nexit\n'})}),"\n",(0,i.jsx)(n.p,{children:"As you can probably notice from the configuration above, to configure a Tenant, all you need to do is give it a name. Your name should be descriptive. Optionally, there is a description field you can use to give more context to anyone reviewing your configuration."}),"\n",(0,i.jsxs)(n.p,{children:["Tenants can be children of other Tenants. This means that if you apply an access policy to a parent Tenant, all the children will inherit it. However, if you set the access policy at the child, then the parent will not get that access from the child. You can create the parent-child relationship by how you name your Tenants. The name format is ",(0,i.jsx)(n.code,{children:"child.parent"}),". So for example, if the tenant is ",(0,i.jsx)(n.code,{children:"dallas.corp"}),", then the parent is ",(0,i.jsx)(n.code,{children:"corp"})," and ",(0,i.jsx)(n.code,{children:"dallas"})," is the child. You can have an arbitrary number of levels of tenants within a tenant, such as ",(0,i.jsx)(n.code,{children:"greatgrandchild.grandchild.child.parent"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Traffic gets associated with a Tenant in one of three ways:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Tenancy was assigned by an upstream SSRs and communicated in metadata."}),"\n",(0,i.jsx)(n.li,{children:"By arriving on a Network Interface that has a tenant configured."}),"\n",(0,i.jsxs)(n.li,{children:["By arriving on a network-interface that has a neighborhood configured, and the source IP address of the IP packet is defined within a tenant's ",(0,i.jsx)(n.code,{children:"member > address"})," definition."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In the metadata that SSRs send to each other when using SVR, they include the Tenant traffic has already been assigned. So, if my Seattle Router assigns the ",(0,i.jsx)(n.code,{children:"seattle.corp"})," Tenant to a session and then sends that session to my Boston Router, my Boston Router will already know that this session belongs to the ",(0,i.jsx)(n.code,{children:"seattle.corp"})," Tenant and use that information in determining if this session has access to the Service it is trying to access."]}),"\n",(0,i.jsx)(n.p,{children:"At the Network Interface, you can also assign a Tenant and if any traffic that doesn't already have a Tenant assigned ingresses this Network Interface, it will belong to that Tenant."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"device-interface  lan1\n    name               lan1\n    pci-address        0000:00:03.0\n    \n    network-interface  lan1\n        name       lan1\n        global-id  4\n        tenant     seattle.corp\n    \n        address    192.168.64.1\n            ip-address     192.168.64.1\n            prefix-length  24\n        exit\n    exit\nexit\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Lastly, if you are using neighborhoods, then you can associate tenancy based on the originating subnet. Within the tenant configuration, you will find a sub-element called ",(0,i.jsx)(n.code,{children:"member"}),". The ",(0,i.jsx)(n.code,{children:"member"})," element defines the association of IP address ranges within a neighborhood to a tenant. If a network interface belongs to that neighborhood, and the source address of the traffic that ingresses that network interface falls into one of the subnets assigned to that tenant, then the traffic will be associated to that tenant. This technique allows you to correlate traffic into an array of tenants when it arrives on a single network interface."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"tenant          corp\n    name    corp\n    \n    member  mpls\n        neighborhood  mpls\n        address       192.168.64.1/24\n        address       10.0.0.0/24\n    exit\nexit\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, any traffic arriving on an interface that is part of the ",(0,i.jsx)(n.code,{children:"mpls"})," neighborhood, will be associated with the ",(0,i.jsx)(n.code,{children:"corp"})," tenant if it is sourced from 192.168.64.0/24 or 10.0.0.0/24."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["Some configurations elect to use this technique for tenant association in lieu of the previous technique (assigning a tenant to a network-interface). This is done by associating the network-interface with a neighborhood, and setting the ",(0,i.jsx)(n.code,{children:"member > address"})," prefix to ",(0,i.jsx)(n.code,{children:"0.0.0.0/0"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"service-layer",children:"Service Layer"}),"\n",(0,i.jsx)(n.h3,{id:"services",children:"Services"}),"\n",(0,i.jsxs)(n.p,{children:["Services make up the heart of the SSR data model. The SSR data model is built upon the idea that one should build their network around the applications that they will be accessing and not determine which applications their network can access based off of the way their network is set up. In the SSR data model, a ",(0,i.jsx)(n.code,{children:"service"})," is a traffic destination being accessed by constituents in your network."]}),"\n",(0,i.jsx)(n.p,{children:"Service configuration, which represents the cornerstone of the SSR\u2019s worldview, is part of the set of global data within an authority. Services represent specific applications that a network delivers; e.g., web services, database services, or voice/video services. Using a top-down approach, the SSR data model asks that administrators define the services that their network will deliver, the requirements that the service demands (in terms of latency, packet loss, jitter, etc.), and the network topology \u2013 and the SSR will deliver traffic to the service using the optimal paths through the network. Because they are global data within an authority, all services defined within an authority are part of the dataset for each SSRs router that is also a member of that authority."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"service  video\n    name            video\n    enabled         true\n    security        encryption_only\n    \n    transport       tcp\n        protocol    tcp\n    \n        port-range  8554\n            start-port  8554\n        exit\n    exit\n    \n    transport       udp\n        protocol  udp\n    exit\n    address         172.16.128.2/32\n    \n    access-policy   corp\n        source  corp\n    exit\n    service-policy  prefer_broadband\nexit\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"address"})," and ",(0,i.jsx)(n.code,{children:"transport"})," fields indicate the IP address(es), transport protocols, and ports that make up this service. The ",(0,i.jsx)(n.code,{children:"access-policy"})," elements indicate the user populations (typically defined as the name of a ",(0,i.jsx)(n.code,{children:"tenant"}),") that are allowed access to this service."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"The naming convention you choose when modeling your network is very important when you are going back to look at what you configured. Giving your services meaningful names can remove a lot of the guesswork as to what the service you defined actually is \u2013 particularly for those that support this configuration in the future."})}),"\n",(0,i.jsx)(n.h2,{id:"policy-layer",children:"Policy Layer"}),"\n",(0,i.jsx)(n.p,{children:"A set of global policies rounds out the data model; complementing the router-specific policies, the global policies describe the treatment of traffic that flows between SSRs. This includes information on how packets are classified into their various types (e.g., how to differentiate between web traffic, voice traffic, proprietary application traffic, etc.) and the requirements that those traffic varieties have from a networking perspective."}),"\n",(0,i.jsx)(n.h2,{id:"service-policies",children:"Service Policies"}),"\n",(0,i.jsxs)(n.p,{children:["Your Service may be configured with a ",(0,i.jsx)(n.em,{children:"Service Policy"}),". A Service Policy tells each SSRs how to handle traffic destined for that Service. It will define things such as whether the Service will be load balanced and with what strategy, whether session resiliency is set up, and selecting path preference with Vectors. The Service Policy will give you a better understanding of how important a Service is to a deployment and what paths that traffic will take to get to that Service."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"service-policy  prefer_broadband\n    name                         prefer_broadband\n    lb-strategy                  hunt\n    \n    vector                       internet\n        name      internet\n        priority  ordered\n    exit\n    \n    vector                       mpls\n        name      mpls\n        priority  ordered\n    exit\n    session-resiliency           none\n    path-quality-filter          false\n    best-effort                  true\n    transport-state-enforcement  reset\nexit\n"})}),"\n",(0,i.jsx)(n.h2,{id:"vectors",children:"Vectors"}),"\n",(0,i.jsx)(n.p,{children:"Defined in the Service Policy, vectors let you set path priority with your SSRs. You will see the Vectors configured at the Neighborhoods which are sub-elements of the Network Interface. The Service Policy is where you can determine the priority of each Vector when the SSR is deciding which path to send traffic down and thus which Network Interfaces to use."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"network-interface  mpls1\n    name                    mpls1\n    global-id               3\n    vlan                    0\n    type                    external\n    conductor               false\n    \n    neighborhood            mpls\n        name                mpls\n        peer-connectivity   bidirectional\n        topology            spoke\n        vector              mpls\n        qp-value            0\n    \n        udp-transform\n            mode                 auto-detect\n            detect-interval      300\n            nat-keep-alive-mode  disabled\n        exit\n    \n        path-mtu-discovery\n            enabled   false\n            interval  600\n        exit\n    exit\nexit\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When defining vectors within a service-policy for association within a neighborhood, network-interface, or service-route, each will be set with a default priority of ",(0,i.jsx)(n.code,{children:"ordered"}),". The order in which they are configured define the precedence for which a path should be used. The use of ordered vectors triggers the conductor to automatically generate a value for the vector cost. This numbering starts at one and increases by an order of magnitude (1, 10, 100, 1000, 10000, 100000, 999999). Ordered lists longer than six vectors will result in additional vectors autogenerated with the highest configurable cost of 999999 which would result in these vectors being considered equal cost. Therefore, for service-policies with more than six vectors it is required to manually set the cost."]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Advanced Priority Details"}),(0,i.jsx)(n.p,{children:"It is possible to mix explicit vector values with implicit, ordered values, although this is not recommended. For cases where this type of configuration is necessary, the follow example illustrates the system's behavior when doing so:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"admin@conductor-east-1.RTR_EAST_CONDUCTOR (service-policy[name=resiliency-policy])# show\nname                resiliency-policy\n\nvector              local-breakout\n    name      local-breakout\n    priority  20\nexit\n\nvector              svr-primary\n    name  svr-primary\nexit\n\nvector              svr-secondary\n    name      svr-secondary\n    priority  1000\nexit\n\nvector              svr-backup\n    name      svr-backup\n    priority  ordered\nexit\n\nvector              svr-last\n    name      svr-last\n    priority  755\nexit\n"})}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"admin@conductor-east-1.RTR_EAST_CONDUCTOR (service-policy[name=resiliency-policy])# do show service-path service-name east router combo-west node combo-west-a\nFri 2023-12-15 16:12:20 UTC\nNode: combo-west-a.combo-west Page 1\n\n========= =============== =============== ================== ========== =============== ================== ================ ====== ====== ============= ========\n Service   Service-Route   Type            Destination        Hostname   Next-Hop        Interface          Vector           Cost   Rate   Capacity      State\n========= =============== =============== ================== ========== =============== ================== ================ ====== ====== ============= ========\n east      combo-east-a    peer            172.16.101.1/32    -          172.16.101.1    intf11-primary     svr-primary        10      0   0/unlimited   Up(Up)\n east      combo-east-a    peer            172.16.201.1/32    -          172.16.201.1    intf11-secondary   svr-secondary    1000      0   0/unlimited   Up(Up)\n east      test-route      service-agent   172.16.21.101/32   -          172.16.21.101   intf-local         local-breakout     20      0   0/unlimited   Up(Up)\n east      test-route-2    service-agent   172.16.20.101/32   -          172.16.20.101   intf-local         svr-backup       1000      0   0/unlimited   Up(Up)\n east      test-route-3    service-agent   172.16.19.101/32   -          172.16.19.101   intf-local         svr-last          755      0   0/unlimited   Up(Up)\n\n\u2714 Retrieving service paths...\nCompleted in 0.05 seconds\n"})}),(0,i.jsxs)(n.p,{children:["Looking at the configuration snippet carefully, you can see that  ",(0,i.jsx)(n.code,{children:"svr-primary"})," and ",(0,i.jsx)(n.code,{children:"svr-backup"})," did not specify a priority value. The values assigned to these vectors will be determined by their index in the list.\ne.g.,"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"local-breakout - index 0\nsvr-primary    - index 1 \nsvr-secondary  - index 2 \nsvr-backup     - index 3 \nsvr-last       - index 4 \n"})}),(0,i.jsxs)(n.p,{children:["Following from this, ",(0,i.jsx)(n.code,{children:"svr-primary"})," will have a value of 10^1 and ",(0,i.jsx)(n.code,{children:"svr-backup"})," will have a value of 10^3.\nThe vector values translated from this configuration will be:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"local-breakout 20\nsvr-primary    10\nsvr-secondary  1000\nsvr-backup     1000\nsvr-last       755\n"})})]}),"\n",(0,i.jsx)(n.h2,{id:"service-routes",children:"Service Routes"}),"\n",(0,i.jsx)(n.p,{children:"Service Routes are used to tell your SSRs how to reach a particular Service. This is Local Data, so it is only specific to a particular Router. It tells that Router that if you see traffic that matches one of your configured Services, then send it to the following destination. The destination can be one or more SSRs Peers, a gateway, an IP address, a subnet, a blackhole, etc. If the destination is another SSRs, then the SSRs will use Secure Vector Routing to send the traffic."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"service-route         webserver-route\n    name          webserver-route\n    service-name  webserver\n    peer          bostonsite1\nexit\n            \nservice-route                 local-webserver3-route\n    name                  local-webserver3-route\n    service-name          webserver3\n    nat-target            172.36.128.2\n    service-route-policy  lb-policy\nexit\n"})}),"\n",(0,i.jsx)(n.h2,{id:"service-route-policies",children:"Service Route Policies"}),"\n",(0,i.jsx)(n.p,{children:"A Service Route Policy is way to set limits on the Service Routes to use when the SSR is determining which path to take. This is necessary for load balancing. You can set limits based on the max number of concurrent sessions to send down one path or the session rate/second for that path. Service Route Policies get applied to the Service Routes."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"service-route-policy  lb-policy\n    name          lb-policy\n    max-sessions  1000\nexit\n"})}),"\n",(0,i.jsx)(n.h2,{id:"routing-default-instance",children:"Routing Default-Instance"}),"\n",(0,i.jsxs)(n.p,{children:["While using Service Routes with the SSR is the preferred method of routing, you may also encounter deployments that use traditional routing methods such as BGP, OSPF, or Static Routes. You will find the settings for these under ",(0,i.jsx)(n.code,{children:"routing"})," under the Router. The Routing element must have a ",(0,i.jsx)(n.code,{children:"type"})," of ",(0,i.jsx)(n.code,{children:"default-instance"})," but the sub-elements under that will have all the settings you need to set for creating Static Routes, BGP peering, and OSPF peering."]}),"\n",(0,i.jsxs)(n.p,{children:["When the SSR is making routing decisions, it will use traditional administrative distances to figure out which route to use with one exception: Service Routes get priority over every other route. You can see what route will get chosen with ",(0,i.jsx)(n.code,{children:"show fib"}),". You can see the traditional routing decisions with ",(0,i.jsx)(n.code,{children:"show rib"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"routing               default-instance\n    type              default-instance\n\n    routing-protocol  bgp\n        type            bgp\n        local-as        100\n        router-id       1.1.1.128\n\n        address-family  ipv4-unicast\n            afi-safi                ipv4-unicast\n\n            default-route-distance\n                external  69\n                internal  13\n                local     55\n            exit\n\n            network                 192.168.64.0/24\n                network-address  192.168.64.0/24\n                policy           mark-vrfl\n            exit\n        exit\n    exit\nexit\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var i=t(96540);const r={},o=i.createContext(r);function a(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);