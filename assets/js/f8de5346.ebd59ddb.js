"use strict";(self.webpackChunk_128t_docs=self.webpackChunk_128t_docs||[]).push([[8550],{65722:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>a});var i=t(74848),r=t(28453);const s={title:"Kernel Network Interfaces",sidebar_label:"Kernel Network Interfaces"},o=void 0,c={id:"concepts_kni",title:"Kernel Network Interfaces",description:"The DPDK kernel network interface (KNI) provides a way for the SSR to route traffic to the Linux OS for access to various USER space applications. KNIs also provide a way for traffic originating in the Linux OS to be routed via the SSR. Every SSR creates a KNI called kni254 by default which is used to implement in-band management access to the router.",source:"@site/docs/concepts_kni.md",sourceDirName:".",slug:"/concepts_kni",permalink:"/docs/concepts_kni",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1710455842,formattedLastUpdatedAt:"Mar 14, 2024",frontMatter:{title:"Kernel Network Interfaces",sidebar_label:"Kernel Network Interfaces"},sidebar:"docs",previous:{title:"Interface Types",permalink:"/docs/concepts_interface_types"},next:{title:"Linux Host Networking",permalink:"/docs/concepts_linux_host_networking"}},d={},a=[{value:"Configuration",id:"configuration",level:2},{value:"Host KNI",id:"host-kni",level:3},{value:"Bridge KNI",id:"bridge-kni",level:3},{value:"Scripting Framework",id:"scripting-framework",level:2},{value:"Directory structure",id:"directory-structure",level:3},{value:"Script Types",id:"script-types",level:3},{value:"startup",id:"startup",level:4},{value:"init",id:"init",level:4},{value:"monitoring",id:"monitoring",level:4},{value:"reinit",id:"reinit",level:4},{value:"shutdown",id:"shutdown",level:4},{value:"info",id:"info",level:4},{value:"state",id:"state",level:4},{value:"Script command line arguments",id:"script-command-line-arguments",level:3},{value:"Script Requirements",id:"script-requirements",level:3},{value:"References",id:"references",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The DPDK kernel network interface (KNI) provides a way for the SSR to route traffic to the Linux OS for access to various USER space applications. KNIs also provide a way for traffic originating in the Linux OS to be routed via the SSR. Every SSR creates a KNI called ",(0,i.jsx)(n.code,{children:"kni254"})," by default which is used to implement ",(0,i.jsx)(n.a,{href:"/docs/concepts_linux_host_networking",children:"in-band management access"})," to the router."]}),"\n",(0,i.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsxs)(n.p,{children:["There are several types of interfaces in the product that leverage KNIs such as ",(0,i.jsx)(n.a,{href:"/docs/howto_lte",children:"LTE"}),", PPPoE and T1 are all implemented using KNIs under the covers. The SSR router also provides the ability to provision KNIs in various modes and provides an extensible scripting framework around them."]}),"\n",(0,i.jsx)(n.h3,{id:"host-kni",children:"Host KNI"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"host"})," mode KNI creates a KNI in Linux with the name specified. The following configuration shows the example of such KNI"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"config\n\n    authority\n\n        router  router1\n            name  router1\n\n            node  node1\n                name              node1\n\n                device-interface  host-kni\n                    name               host-kni\n                    type               host\n                    enabled            true\n\n                    network-interface  host-kni-intf\n                        name       host-kni-intf\n                        tenant     _internal_\n\n                        address    169.254.10.20\n                            ip-address     169.254.10.20\n                            prefix-length  24\n                            gateway        169.254.10.21\n                        exit\n                    exit\n                exit\n            exit\n        exit\n    exit\nexit\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The above configuration, creates a KNI called ",(0,i.jsx)(n.code,{children:"host-kni"})," in Linux which can be utilized for sending and/or receiving traffic from the SSR. The configured ",(0,i.jsx)(n.code,{children:"gateway"})," will be added as the IP address of the interface in Linux and the ",(0,i.jsx)(n.code,{children:"ip-address"})," will be added as the gateway for the KNI from Linux's perspective."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# ip addr\n...\n89: host-kni: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\n    link/ether 36:10:e9:cc:16:3c brd ff:ff:ff:ff:ff:ff\n    inet 169.254.10.21/24 brd 169.254.10.255 scope global host-kni\n       valid_lft forever preferred_lft forever\n    inet6 fe80::3410:e9ff:fecc:163c/64 scope link\n       valid_lft forever preferred_lft forever\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Users can also configure a ",(0,i.jsx)(n.code,{children:"network-namespace"})," for the host KNI which is useful for isolating the host KNI into a namespace and is commonly how KNIs are used. Applications and plugins leverage the ",(0,i.jsx)(n.a,{href:"#scripting-framework",children:"scripting framework"})," in order to implement ",(0,i.jsx)(n.a,{href:"/docs/plugin_intro#service-function-chaining",children:"SFC"}),". To simplify the adoption of this model and to speed up plugin development using this model, ",(0,i.jsx)(n.a,{href:"/docs/plugin_kni_namespace_scripts",children:"a utility with a set of namespace scripts"})," is provided to simplify this process."]}),"\n",(0,i.jsx)(n.h3,{id:"bridge-kni",children:"Bridge KNI"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"bridge"})," mode KNI is used to create a Linux bridge with another ethernet interface in Linux. The following configuration shows an example of such a KNI"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"config\n\n    authority\n\n        router  router1\n            name  router1\n\n            node  node1\n                name              node1\n\n                device-interface  test-bridge\n                    name               test-bridge\n                    type               bridged\n                    target-interface   dpdk3\n\n                    network-interface  test-bridge-intf\n                        name        test-bridge-intf\n                        global-id   7\n                        tenant      _internal_\n                        source-nat  true\n\n                        address     169.254.100.100\n                            ip-address     169.254.100.100\n                            prefix-length  24\n                        exit\n                    exit\n                exit\n            exit\n        exit\n    exit\nexit\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this mode, the SSR router will create a Linux bridge (of the form ",(0,i.jsx)(n.code,{children:"kni<global-id>_bridge"}),"). To make the bridge name more predictable or to use an existing bridge network user can also configure the ",(0,i.jsx)(n.code,{children:"bridge-name"})," field for the KNI. Once applied, the system will put both the KNI called ",(0,i.jsx)(n.code,{children:"test-bridge"})," and ",(0,i.jsx)(n.code,{children:"dpdk3"})," interface on the same bridge interface. In addition, the router will perform a mac swap by first learning the ",(0,i.jsx)(n.code,{children:"mac-address"})," of the target-interface ",(0,i.jsx)(n.code,{children:"dpdk3"})," and installing it on the KNI and installing the randomly generated KNI MAC address on the bridge and target interfaces."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-console",children:"# ip addr\n...\n5: dpdk3: <BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast kni7_bridge state UP group default qlen 1000\n    link/ether ee:43:6b:45:51:7e brd ff:ff:ff:ff:ff:ff\n    inet6 fe80::ec43:6bff:fe45:517e/64 scope link\n       valid_lft forever preferred_lft forever\n...\n93: test-bridge: <BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast kni7_bridge state UP group default qlen 1000\n    link/ether ee:43:6b:45:51:7e brd ff:ff:ff:ff:ff:ff\n94: kni7_bridge: <BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000\n    link/ether ee:43:6b:45:51:7e brd ff:ff:ff:ff:ff:ff\n    inet6 fe80::ec43:6bff:fe45:517e/64 scope link\n       valid_lft forever preferred_lft forever\n"})}),"\n",(0,i.jsx)(n.h2,{id:"scripting-framework",children:"Scripting Framework"}),"\n",(0,i.jsxs)(n.p,{children:["The KNI scripting framework provides a programmable interface to bring-up, initialize and monitor applications that are associated with KNIs. Several of the built in device types such as LTE, PPPoE and T1 all leverage this framework to implement majority of their functions. Other features in the product such as DHCP server and ",(0,i.jsx)(n.a,{href:"/docs/plugin_intro#service-function-chaining",children:"plugins"})," also leverage this scripting framework."]}),"\n",(0,i.jsx)(n.h3,{id:"directory-structure",children:"Directory structure"}),"\n",(0,i.jsxs)(n.p,{children:["The scripting framework scans for executable scripts in the ",(0,i.jsx)(n.code,{children:"/etc/128technology/plugins/network-scripts"})," directory for each of the configured types. Each of the built in type has its own dedicated sub-directory called ",(0,i.jsx)(n.code,{children:"lte"}),", ",(0,i.jsx)(n.code,{children:"pppoe"})," and ",(0,i.jsx)(n.code,{children:"t1"})," where the router stages the necessary scripts. For the ",(0,i.jsx)(n.code,{children:"host"})," type interface, the software will look for scripts in a sub-directory by the name of the KNI interface under ",(0,i.jsx)(n.code,{children:"/etc/128technology/plugins/network-scripts/host/"}),". For the ",(0,i.jsx)(n.code,{children:"bridge"})," type interface, the software will look for a scripts in a sub-directory by the name of the ",(0,i.jsx)(n.code,{children:"target-interface"})," under ",(0,i.jsx)(n.code,{children:"/etc/128technology/plugins/network-scripts/bridged/"}),". From the above example, this will be ",(0,i.jsx)(n.code,{children:"128technology/plugins/network-scripts/host/host-kni"})," and ",(0,i.jsx)(n.code,{children:"/etc/128technology/plugins/network-scripts/bridged/dpdk3"})," respectively."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-console",children:"# ls /etc/128technology/plugins/network-scripts/\nbridged  common  default  dhcp-server  host  kni  pppoe  t1\n\n# ls /etc/128technology/plugins/network-scripts/host/\nhost-kni\n\n# ls /etc/128technology/plugins/network-scripts/bridged/\ndpdk3\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"important",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"root"})," access is required for executing all the scripts"]})}),"\n",(0,i.jsx)(n.h3,{id:"script-types",children:"Script Types"}),"\n",(0,i.jsx)(n.p,{children:"The framework supports a set of scripts to assist in the initialization, maintenance and graceful shutdown of applications built around the KNIs. These scripts are run at various logic points in the code and expected to trigger specific behavior per the contract."}),"\n",(0,i.jsx)(n.h4,{id:"startup",children:"startup"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"startup"})," script is executed when the KNI is created for the first time. This typically happens when either a new KNI config is added or the SSR service (re)starts. This is typically the place where the application should perform any cleanup of previous context, perform one time operations such as loading necessary drivers etc."]}),"\n",(0,i.jsx)(n.h4,{id:"init",children:"init"}),"\n",(0,i.jsxs)(n.p,{children:["Once the interface is created and started, the ",(0,i.jsx)(n.code,{children:"init"})," script will be invoked to initialize the KNI and the underlying application. This is where typically the bulk of the operation happens such as moving KNIs and other interfaces (if needed) to a network namespace, launching other applications, setting up Linux routing etc. Once this state is complete, the system is expected to be in an operation state with regards to this KNI."]}),"\n",(0,i.jsx)(n.h4,{id:"monitoring",children:"monitoring"}),"\n",(0,i.jsxs)(n.p,{children:["While the interface is up, the ",(0,i.jsx)(n.code,{children:"monitoring"})," script is invoked every ",(0,i.jsx)(n.code,{children:"1 second"})," and is meant to inspect the health of the KNI and its application. This is typically where the user could check for the status of the systemd service, some upstream connectivity etc. The script can report the word ",(0,i.jsx)(n.code,{children:"down"})," over standard out to the SSR software to bring the interface operationally down. Once in this state, the system will continue to run the ",(0,i.jsx)(n.code,{children:"monitoring"})," script to detect any other change in status if necessary."]}),"\n",(0,i.jsx)(n.h4,{id:"reinit",children:"reinit"}),"\n",(0,i.jsxs)(n.p,{children:["In a normal scenario, the system is monitoring the operational status of the KNI as well as the bridge and target interface for the bridge type. At any point if the operational status goes down or the ",(0,i.jsx)(n.code,{children:"monitoring"})," script reports down, the system has a ",(0,i.jsx)(n.code,{children:"10 second"})," hold down time to let the system normalize on its own and then calls the ",(0,i.jsx)(n.code,{children:"reinit"})," script to try and reinitialize the device. This provides an opportunity for the application to perform any cleanup before re-initializing the connection. In most cases, this will perform the same tasks as the ",(0,i.jsx)(n.code,{children:"init"})," script."]}),"\n",(0,i.jsx)(n.h4,{id:"shutdown",children:"shutdown"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"shutdown"})," script is called when the SSR router is stopped or if the KNI interface is deleted from the configuration. The script is intended to do final cleanup such as deleting namespaces, restoring routes in global namespace, etc."]}),"\n",(0,i.jsx)(n.h4,{id:"info",children:"info"}),"\n",(0,i.jsxs)(n.p,{children:["When the interface comes up for the first time or after any subsequent ",(0,i.jsx)(n.code,{children:"down"})," to ",(0,i.jsx)(n.code,{children:"up"})," transition, the system invokes the ",(0,i.jsx)(n.code,{children:"info"})," script. The script can produce a JSON document which will be used to provide an output within the ",(0,i.jsx)(n.code,{children:"show platform"})," command for the KNI interface. This is useful for capturing and reporting static information such as software or firmware version."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "Device Info": {\n        "IMEI": "359225056050065",\n        "Model": "MC7354",\n        "Firmware Version": "SWI9X15C_05.05.58.00 r27038 carmd-fwbuild1 2015/03/04 21:30:23",\n        "Manufacturer": "Sierra Wireless, Incorporated"\n    },\n    "Network Info": {\n        "Wireless Network": "LTE",\n        "Supported Technology": "GSM, GPRS, EDGE, UMTS, HSDPA/HSUPA, HSPA+, LTE",\n        "Sim Type": "3G USIM"\n    },\n    "Carrier Info": {\n        "preferred carrier name": "GENNA-UMTS",\n        "current fw version": "05.05.58.00",\n        "current config name": "GENNA-UMTS_005.025_002",\n        "current carrier name": "GENNA-UMTS",\n        "preferred fw version": "05.05.58.00",\n        "preferred config name": "GENNA-UMTS_005.025_002"\n    }\n}\n\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"The script will be terminated if it takes longer than 30 seconds to finish."})}),"\n",(0,i.jsx)(n.h4,{id:"state",children:"state"}),"\n",(0,i.jsxs)(n.p,{children:["The system invokes another script called ",(0,i.jsx)(n.code,{children:"state"})," every ",(0,i.jsx)(n.code,{children:"5 seconds"})," and is useful for capturing dynamic information associated with the KNI such as application status, connection status etc. The script can produce a JSON output to standard out and the content is displayed as part of ",(0,i.jsx)(n.code,{children:"show device-interface"})," command."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "GRE": {\n        "stats": {\n            "TX errors:": {\n                "transns": "0",\n                "heartbeat": "0",\n                "window": "0",\n                "aborted": "0",\n                "fifo": "0"\n            },\n            "TX": {\n                "collsns": "0",\n                "errors": "1",\n                "dropped": "0",\n                "bytes": "10428144",\n                "carrier": "1",\n                "packets": "289627"\n            },\n            "RX": {\n                "mcast": "0",\n                "overrun": "0",\n                "errors": "0",\n                "dropped": "0",\n                "bytes": "10419744",\n                "packets": "289408"\n            },\n            "RX errors": {\n                "missed": "0",\n                "fifo": "0",\n                "frame": "0",\n                "length": "0",\n                "crc": "0"\n            }\n        },\n        "icmp-probe-status": "unavailable"\n    }\n}\n\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"The script will be terminated if it takes longer than 30 seconds to finish."})}),"\n",(0,i.jsx)(n.h3,{id:"script-command-line-arguments",children:"Script command line arguments"}),"\n",(0,i.jsxs)(n.p,{children:["In order to provide actionable information for script to perform their automation, each of the scripts are provided with a set of command line arguments that reflects the SSR configuration, specifically for the ",(0,i.jsx)(n.code,{children:"host"})," and ",(0,i.jsx)(n.code,{children:"bridged"})," types the following information is provided"]}),"\n",(0,i.jsxs)(n.p,{children:["Each script for the ",(0,i.jsx)(n.code,{children:"host"})," type is passed each of the following arguments"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"arguments"}),(0,i.jsx)(n.th,{children:"description"}),(0,i.jsx)(n.th,{children:"example"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"--kni-interface=<kni-intf-name>"})}),(0,i.jsx)(n.td,{children:"name of the device-interface"}),(0,i.jsx)(n.td,{children:"host-kni"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"--kni-ip=<kni-interface-ip>"})}),(0,i.jsx)(n.td,{children:"ip-address of the network-interface"}),(0,i.jsx)(n.td,{children:"169.254.10.20"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"--kni-prefix=<kni-interface-prefix>"})}),(0,i.jsx)(n.td,{children:"prefix-length of network-interface"}),(0,i.jsx)(n.td,{children:"24"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"--kni-gateway=<kni-interface-gateway>"})}),(0,i.jsx)(n.td,{children:"gateway of network-interface"}),(0,i.jsx)(n.td,{children:"169.254.10.21"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"--namespace=<namespace-name>"})}),(0,i.jsxs)(n.td,{children:["Optional: If ",(0,i.jsx)(n.code,{children:"network-namespace"})," is configured"]}),(0,i.jsx)(n.td,{children:"None"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["Each script for the ",(0,i.jsx)(n.code,{children:"bridged"})," type is passed each of the following arguments"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"arguments"}),(0,i.jsx)(n.th,{children:"description"}),(0,i.jsx)(n.th,{children:"example"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"--kni-interface=<kni-intf-name>"})}),(0,i.jsx)(n.td,{children:"name of the device-interface"}),(0,i.jsx)(n.td,{children:"test-bridge"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"--target-interface=<target-intf-name>"})}),(0,i.jsx)(n.td,{children:"name of the target-interface"}),(0,i.jsx)(n.td,{children:"dpdk3"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"--bridge=<bridge-name>"})}),(0,i.jsxs)(n.td,{children:["auto generated bridge name or ",(0,i.jsx)(n.code,{children:"bridge-name"})," from config"]}),(0,i.jsx)(n.td,{children:"kni7_bridge"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"script-requirements",children:"Script Requirements"}),"\n",(0,i.jsx)(n.p,{children:"The following requirements apply to the scripts:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The name of the scripts are case sensitive, must match the names in the previous sections and should not include any file extension. For example, init.sh is not a valid ",(0,i.jsx)(n.code,{children:"init"})," script. Similarly ",(0,i.jsx)(n.code,{children:"STATE"})," is also not considered a valid name for ",(0,i.jsx)(n.code,{children:"state"})," script."]}),"\n",(0,i.jsxs)(n.li,{children:["The scripts must be executable and must have execute permission for ",(0,i.jsx)(n.code,{children:"root"})," user"]}),"\n",(0,i.jsxs)(n.li,{children:["The scripts must have the ability to interpret ",(0,i.jsx)(n.a,{href:"#script-command-line-arguments",children:"command line arguments"})," containing ip-address and other information."]}),"\n",(0,i.jsxs)(n.li,{children:["The scripts are language agnostic as long as the operating system can understand how to execute them. This is typically accomplished by including an interpreter shebang such as ",(0,i.jsx)(n.code,{children:"#!/bin/bash"})," as the first line of the script. More details can be found ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Shebang_(Unix)",children:"here"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The scripts must exit with a code of ",(0,i.jsx)(n.code,{children:"zero"})," to indicate success and use a ",(0,i.jsx)(n.code,{children:"non-zero"})," code to indicate a failure."]}),"\n",(0,i.jsxs)(n.li,{children:["Some scripts such as ",(0,i.jsx)(n.code,{children:"monitoring"}),", ",(0,i.jsx)(n.code,{children:"state"})," and ",(0,i.jsx)(n.code,{children:"info"})," are expected to produce output on ",(0,i.jsx)(n.code,{children:"stdout"}),". The format of this output depends on the type of the script."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://doc.dpdk.org/guides-21.11/prog_guide/kernel_nic_interface.html",children:"Kernel NIC Interface"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Shebang_(Unix)",children:"Linux Interpreter Shebang"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var i=t(96540);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);