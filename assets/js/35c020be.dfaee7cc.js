"use strict";(self.webpackChunk_128t_docs=self.webpackChunk_128t_docs||[]).push([[4031],{37306:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>d});var t=n(74848),r=n(28453);const c={title:"Per Adjacency Traffic Engineering",sidebar_label:"Per Adjacency Traffic Engineering"},a=void 0,s={id:"bcp_per-adjacency_traffic_engineering",title:"Per Adjacency Traffic Engineering",description:"Packet loss due to congestion in networks, particularly over WAN links, is inevitable. Depending on where drops occur, it can have a major impact on perceived quality of experience. Packet loss due to exceeding transmit caps between instances of SSR should be avoided. Per-adjacency traffic engineering can be enabled to regulate the upload and download rates between peers.",source:"@site/docs/bcp_per-adjacency_traffic_engineering.md",sourceDirName:".",slug:"/bcp_per-adjacency_traffic_engineering",permalink:"/docs/bcp_per-adjacency_traffic_engineering",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1710939338,formattedLastUpdatedAt:"Mar 20, 2024",frontMatter:{title:"Per Adjacency Traffic Engineering",sidebar_label:"Per Adjacency Traffic Engineering"},sidebar:"docs",previous:{title:"Monitoring Head End Routers",permalink:"/docs/bcp_monitoring_headends"},next:{title:"Saltstack at Scale With SSR",permalink:"/docs/bcp_salt_pillars"}},o={},d=[{value:"Overview",id:"overview",level:2},{value:"Traffic Profile",id:"traffic-profile",level:3},{value:"Auto-Configuration via Neighborhoods",id:"auto-configuration-via-neighborhoods",level:3},{value:"Manual Configuration via Adjacencies",id:"manual-configuration-via-adjacencies",level:3},{value:"Gathering Statistics",id:"gathering-statistics",level:3},{value:"Additional Information",id:"additional-information",level:3}];function l(e){const i={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.p,{children:"Packet loss due to congestion in networks, particularly over WAN links, is inevitable. Depending on where drops occur, it can have a major impact on perceived quality of experience. Packet loss due to exceeding transmit caps between instances of SSR should be avoided. Per-adjacency traffic engineering can be enabled to regulate the upload and download rates between peers."}),"\n",(0,t.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(i.p,{children:["Per-adjacency traffic engineering provides targeted traffic engineering for both directions on a bandwidth restricted link between two SSR instances. Traffic engineering on the device interface continues to be associated with the upload rate of a connected link; the ",(0,t.jsx)(i.code,{children:"transmit-cap"}),". Traffic engineering at the adjacency level is associated with the download limit of the adjacent SSR instance; the ",(0,t.jsx)(i.code,{children:"receive-cap"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["For example, in the following hub and spoke diagram the Datacenter router has 5 adjacencies off of the individual device interface with a ",(0,t.jsx)(i.code,{children:"transmit-cap"})," upload speed configured at 50Mb. The adjacent branch routers have 10Mb, 5Mb, 1Mb, 5Mb, and 2.5Mb configured as their device interface transmit caps. With such a large ",(0,t.jsx)(i.code,{children:"transmit-cap"})," at the Datacenter, traffic rates exceeding the allowed download speeds (10Mb, 5Mb, 1Mb, 5Mb, and 2.5Mb) on each of the paths to the branch routers will result in traffic being dropped by the ISP."]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"Hub and Spoke Network",src:n(31948).A+"",width:"914",height:"854"})}),"\n",(0,t.jsxs)(i.p,{children:["Per-adjacency traffic engineering allows you to automatically identify the adjacent path and the ",(0,t.jsx)(i.code,{children:"receive-cap"}),", and limit the rate of traffic destined for that path. With a ",(0,t.jsx)(i.code,{children:"receive-cap"})," configured for each adjacency, traffic does not exceed the ",(0,t.jsx)(i.code,{children:"receive-cap"})," associated with the adjacency, and is not dropped by the ISP."]}),"\n",(0,t.jsx)(i.h3,{id:"traffic-profile",children:"Traffic Profile"}),"\n",(0,t.jsxs)(i.p,{children:["A traffic profile allows you to adjust the amount of bandwidth allocated for various traffic categories. When a traffic profile is configured, it is applied on a network or device interface. Note that the values for best-effort, high, medium, and low are percentage values, and collectively must add up to 100 percent. See ",(0,t.jsx)(i.a,{href:"/docs/config_reference_guide#traffic-profile",children:(0,t.jsx)(i.code,{children:"traffic-profile"})})," for additional information."]}),"\n",(0,t.jsx)(i.h3,{id:"auto-configuration-via-neighborhoods",children:"Auto-Configuration via Neighborhoods"}),"\n",(0,t.jsx)(i.admonition,{type:"note",children:(0,t.jsx)(i.p,{children:"Per adjacency traffic-engineering is limited to spoke nodes in a hub and spoke topology."})}),"\n",(0,t.jsxs)(i.p,{children:["Typically, adjacencies are automatically configured via ",(0,t.jsx)(i.a,{href:"/docs/concepts_glossary#neighborhoods",children:"neighborhoods"}),". All nodes in a neighborhood share layer 3 connectivity. Between any two nodes we can form a pair of adjacencies, one on each router, which describes their peering. When the adjacencies are automatically created, the spoke\u2019s neighborhood ",(0,t.jsx)(i.code,{children:"receive-cap"})," is inspected by the neighborhood Hub router. It creates an adjacency with a ",(0,t.jsx)(i.code,{children:"transmit-cap"})," matching the spoke\u2019s ",(0,t.jsx)(i.code,{children:"receive-cap"}),"."]}),"\n",(0,t.jsxs)(i.admonition,{type:"note",children:[(0,t.jsx)(i.mdxAdmonitionTitle,{}),(0,t.jsxs)(i.p,{children:["In order to generate the adjacencies correctly, configure a ",(0,t.jsx)(i.code,{children:"receive-cap"})," on the neighborhood of the network interface with limited receive capabilities."]})]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"network-interface foo\n    neighborhood bar\n        topology spoke\n  vector internet\n        traffic-engineering\n            enabled true\n            receive-cap 1000000 (<---)\n\t      traffic-profile profile\n        exit\n    exit\nexit\n"})}),"\n",(0,t.jsx)(i.h3,{id:"manual-configuration-via-adjacencies",children:"Manual Configuration via Adjacencies"}),"\n",(0,t.jsxs)(i.p,{children:["The preferred method for configuring adjacencies is using auto-configure via neighborhoods. However, it is possible to manually configure per adjacency traffic-engineering. To limit the router\u2019s transmit speeds when communicating with a specific peer, set the ",(0,t.jsx)(i.code,{children:"traffic-engineering"})," container in the adjacency to have the desired ",(0,t.jsx)(i.code,{children:"transmit-cap"}),"."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"network-interface foo\n    adjacency 1.1.1.1\n        ip-address 1.1.1.1\n        peer peer_router\n        inter-router-security interfabric\n        peer-connectivity bidirectional\n        traffic-engineering\n            enabled true\n            transmit-cap 1000000\n\ttraffic-profile profile\n        exit\n    exit\nexit\n"})}),"\n",(0,t.jsx)(i.h3,{id:"gathering-statistics",children:"Gathering Statistics"}),"\n",(0,t.jsxs)(i.p,{children:["To gather information about Per-Adjacency Traffic Engineering, query the following statistics using the ",(0,t.jsx)(i.code,{children:"show stats traffic-eng device-interface peer-path"})," command within the CLI. These statistics are specific to the peer-path and provide insight into how the adjacency schedulers are operating."]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"enqueue-cycle-count"}),": The current enqueue cycle count in traffic engineering for this peer path."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"dequeue-cycle-count"}),": The current dequeue cycle count in traffic engineering for this peer path."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"packets-queued"}),": The current number of packets queued in traffic engineering for this peer path."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"per-traffic-class schedule-success-bytes"}),": The number of bytes successfully scheduled for transmission for this peer path."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"per-traffic-class schedule-success-packets"}),": The number of packets successfully scheduled for transmission for this peer path."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"per-traffic-class schedule-failure-bytes"}),": The number of bytes failed to be scheduled for transmission due to bandwidth oversubscription for this peer path."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"per-traffic-class schedule-failure-packets"}),": The number of packets failed to be scheduled for transmission due to bandwidth oversubscription for this peer path."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"per-traffic-class dequeue-success-bytes"}),": The number of bytes successfully dequeued from the scheduler for transmission for this peer path."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"per-traffic-class dequeue-success-packets"}),": The number of packets successfully dequeued from the scheduler for transmission for this peer path."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"per-traffic-class dequeue-max-latency-drop-bytes"}),": The number of bytes scheduled for transmission that were dropped due to excessive latency for this peer path."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"per-traffic-class dequeue-max-latency-drop-packets"}),": The number of packets scheduled for transmission that were dropped due to excessive latency for this peer path."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"per-traffic-class dequeue-aqm-drop-bytes"}),": The number of bytes scheduled for transmission that were dropped due to Active Queue Management for this peer path."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"per-traffic-class dequeue-aqm-drop-packets"}),": The number of packets scheduled for transmission that were dropped due to Active Queue Management for this peer path."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"per-traffic-class buffer-capacity-exceeded-bytes"}),": The number of bytes failed to be scheduled for transmission due to exceeded buffer capacity for this peer path."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"per-traffic-class buffer-capacity-exceeded-packets"}),": The number of packets failed to be scheduled for transmission due to exceeded buffer capacity for this peer path."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"per-traffic-class schedule-success-bandwidth"}),": Traffic bandwidth successfully scheduled for transmission for this peer path."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"per-traffic-class schedule-failure-bandwidth"}),": Current scheduler enqueue failure rate in bytes per second for a given traffic class within the scheduler."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"additional-information",children:"Additional Information"}),"\n",(0,t.jsx)(i.p,{children:"Per adjacency traffic engineering works well in a one-to-many topology described above. However, it is less effective in the following topologies:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Topologies where multiple routers are communicating with a bandwidth-restricted branch router. Multiple routers sourcing traffic into the ISP destined for the branch router do not communicate how much traffic they are sending. As a result, oversubscription of the link is possible and the distribution of prioritized traffic from the sourcing routers will be dropped."}),"\n",(0,t.jsx)(i.li,{children:"A topology that includes multiple active paths from an individual datacenter router to the branch routers."}),"\n",(0,t.jsx)(i.li,{children:"A Full-mesh topology."}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},31948:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/per_adjacency_example-3a4ebfbc33dc3a70e90cf087b7f51b3e.png"},28453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>s});var t=n(96540);const r={},c=t.createContext(r);function a(e){const i=t.useContext(c);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function s(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(c.Provider,{value:i},e.children)}}}]);