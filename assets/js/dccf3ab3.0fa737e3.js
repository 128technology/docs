"use strict";(self.webpackChunk_128t_docs=self.webpackChunk_128t_docs||[]).push([[2170],{98646:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var i=s(74848),t=s(28453);const r={title:"DNS Cache Plugin",sidebar_label:"DNS Cache"},d=void 0,l={id:"plugin_dns_cache",title:"DNS Cache Plugin",description:"The SSR-dns-cache plugin provides a DNS caching service on your SSR router by forwarding all traffic on a configured ingress-service and tenant to dnsmasq. By default it uses existing system configuration for nameserver resolution, but supports optionally configuring custom server addresses. The plugin is implemented as a service function chain (SFC) where the DNS traffic received on an ingress interface is detoured through a Kernel Network Interface (KNI) to be cached by dnsmasq. A typical flow of the packets for the plugin is illustrated below:",source:"@site/docs/plugin_dns_cache.md",sourceDirName:".",slug:"/plugin_dns_cache",permalink:"/docs/plugin_dns_cache",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1711026369,formattedLastUpdatedAt:"Mar 21, 2024",frontMatter:{title:"DNS Cache Plugin",sidebar_label:"DNS Cache"},sidebar:"docs",previous:{title:"DNS App Id",permalink:"/docs/plugin_dns_app_id"},next:{title:"GRE",permalink:"/docs/plugin_gre"}},a={},c=[{value:"Configuration",id:"configuration",level:2},{value:"Notes about the Sample Configuration",id:"notes-about-the-sample-configuration",level:3},{value:"Custom DNS Servers",id:"custom-dns-servers",level:3},{value:"Redirecting and blocking domains",id:"redirecting-and-blocking-domains",level:3},{value:"Version History",id:"version-history",level:5},{value:"Custom Options",id:"custom-options",level:3},{value:"Version History",id:"version-history-1",level:5},{value:"Third Party Software and Licenses",id:"third-party-software-and-licenses",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Release Notes",id:"release-notes",level:2},{value:"Release 3.5.0",id:"release-350",level:3},{value:"New Features and Improvements",id:"new-features-and-improvements",level:4},{value:"Release 3.4.0",id:"release-340",level:3},{value:"New Features and Improvements",id:"new-features-and-improvements-1",level:4},{value:"Release 3.3.1",id:"release-331",level:3},{value:"New Features and Improvements",id:"new-features-and-improvements-2",level:4},{value:"Issues Fixed",id:"issues-fixed",level:4},{value:"Release 3.2.2",id:"release-322",level:3},{value:"Issues Fixed",id:"issues-fixed-1",level:4},{value:"Release 3.2.1",id:"release-321",level:3},{value:"Issues Fixed",id:"issues-fixed-2",level:4},{value:"Release 3.1.0",id:"release-310",level:3},{value:"Issues Fixed",id:"issues-fixed-3",level:4},{value:"Release 1.2.0, 2.2.0",id:"release-120-220",level:3},{value:"Issues Fixed",id:"issues-fixed-4",level:4},{value:"Release 1.1.0, 2.1.0",id:"release-110-210",level:3},{value:"New Features and Improvements",id:"new-features-and-improvements-3",level:4},{value:"Issues Fixed",id:"issues-fixed-5",level:4},{value:"Release 1.0.1, 2.0.1",id:"release-101-201",level:3},{value:"Issues Fixed",id:"issues-fixed-6",level:4}];function o(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The SSR-dns-cache plugin provides a DNS caching service on your SSR router by forwarding all traffic on a configured ",(0,i.jsx)(n.code,{children:"ingress-service"})," and ",(0,i.jsx)(n.code,{children:"tenant"})," to ",(0,i.jsx)(n.a,{href:"http://www.thekelleys.org.uk/dnsmasq/doc.html",children:"dnsmasq"}),". By default it uses existing system configuration for nameserver resolution, but supports optionally configuring custom server addresses. The plugin is implemented as a ",(0,i.jsx)(n.a,{href:"/docs/plugin_intro#service-function-chaining",children:"service function chain"})," (SFC) where the DNS traffic received on an ingress interface is detoured through a ",(0,i.jsx)(n.a,{href:"/docs/concepts_kni",children:"Kernel Network Interface"})," (KNI) to be cached by ",(0,i.jsx)(n.code,{children:"dnsmasq"}),". A typical flow of the packets for the plugin is illustrated below:"]}),"\n",(0,i.jsxs)(n.p,{children:["lan-intf (lan-tenant) > ",(0,i.jsx)(n.code,{children:"ingress-service"})," > ",(0,i.jsx)(n.code,{children:"dnsmasq"})," > dns-kni (",(0,i.jsx)(n.code,{children:"tenant"}),") > egress-service > wan-intf"]}),"\n",(0,i.jsx)(n.p,{children:"By enabling this plugin, you can provide DNS caching with fast resolution times to your network."}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["The instructions for installing and managing the plugin can be found ",(0,i.jsx)(n.a,{href:"/docs/plugin_intro#installation-and-management",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsx)(n.p,{children:"Assuming the below SSR configuration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"config\n    authority\n        name Authority128\n        conductor-address labconductor.acme.com\n        tenant dns-cache-plugin\n            name dns-cache-plugin\n        exit\n        tenant lan-clients\n            name lan-clients\n            security aes1\n        exit\n        service internet\n            name internet\n            security internal\n            address 0.0.0.0/0\n            access-policy lan-clients\n                source lan-clients\n                permission allow\n            exit\n            access-policy dns-cache-plugin\n                source dns-cache-plugin\n                permission allow\n            exit\n            share-service-routes false\n        exit\n        service dns-catcher\n            name dns-catcher\n            transport udp\n                protocol udp\n                port-range 53\n                    start-port 53\n                exit\n            exit\n            address 0.0.0.0/0\n            access-policy lan-clients\n                source lan-clients\n                permission allow\n            exit\n        exit\n        router labrouter\n            name labrouter\n            node node1\n                name node1\n                role combo\n                device-interface LAN\n                    name LAN\n                    network-interface vlan0\n                        name vlan0\n                        tenant lan-clients\n                        dhcp v4\n                    exit\n                exit\n            exit\n        exit\n    exit\nexit\n"})}),"\n",(0,i.jsx)(n.p,{children:"We can apply the following DNS cache plugin configuration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"config\n    authority\n        router lab-router\n            name lab-router\n            dns-cache\n                enabled true\n                tenant dns-cache-plugin\n                ingress-service dns-catcher\n            exit\n        exit\n    exit\nexit\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Element"}),(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Default"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"enabled"}),(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsx)(n.td,{children:"true"}),(0,i.jsx)(n.td,{children:"Governs whether the DNS cache is operationally enabled or not."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"name"}),(0,i.jsx)(n.td,{children:"SSR device name"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"dns-cache"})}),(0,i.jsx)(n.td,{children:"This controls the name of the service function chain interface."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"addresses"}),(0,i.jsx)(n.td,{children:"IPv4 address"}),(0,i.jsx)(n.td,{children:"N/A"}),(0,i.jsx)(n.td,{children:"Multiple instance object. This will specify the upstream DNS resolvers to use, overriding the ones normally used by the Linux host operating system on the machine."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"ingress-service"}),(0,i.jsx)(n.td,{children:"reference"}),(0,i.jsx)(n.td,{children:"N/A"}),(0,i.jsxs)(n.td,{children:["This refers to a configured ",(0,i.jsx)(n.code,{children:"service"}),' within the authority that will be used to "trap" inbound DNS requests, to divert them to dnsmasq. Generally, this is a service that has an address of 0.0.0.0/0 and restricted to UDP/53.']})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"plugin-network"}),(0,i.jsx)(n.td,{children:"CIDR"}),(0,i.jsx)(n.td,{children:"169.254.141.128/30"}),(0,i.jsx)(n.td,{children:"This controls the IP addresses used for the internal SFC network to detour packets to and from the on-board DNS cache. This should only be changed if there is a conflict with another IP block in use on this same host system."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"tenant"}),(0,i.jsx)(n.td,{children:"reference"}),(0,i.jsx)(n.td,{children:"N/A"}),(0,i.jsxs)(n.td,{children:["This is the tenant that will be assigned to the SFC interface (of type KNI). All packets leaving the DNS cache and heading toward an upstream DNS resolver will be associated with this tenant. For this reason, it is important that your SSR configuration also includes a ",(0,i.jsx)(n.code,{children:"service"})," that allows this ",(0,i.jsx)(n.code,{children:"tenant"})," to reach the upstream resolvers. Typically, this is an ",(0,i.jsx)(n.code,{children:"internet"})," service (0.0.0.0/0)."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"ingress-source-nat-pool"}),(0,i.jsx)(n.td,{children:"reference"}),(0,i.jsx)(n.td,{children:"N/A"}),(0,i.jsxs)(n.td,{children:["This refers to a configured ",(0,i.jsx)(n.code,{children:"source-nat-pool"}),", and will be used when forwarding the traffic through the DNS cache/service function chain."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"max-ttl"}),(0,i.jsx)(n.td,{children:"seconds"}),(0,i.jsx)(n.td,{children:"1500"}),(0,i.jsxs)(n.td,{children:["The configured maximum TTL will be advertised to clients instead of the true TTL value if it is lower. The true TTL value is however kept in the cache to avoid flooding the upstream DNS servers. See ",(0,i.jsx)(n.a,{href:"#release-120-220",children:"release notes for details"})]})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"notes-about-the-sample-configuration",children:"Notes about the Sample Configuration"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ingress-service"})," we have configured is ",(0,i.jsx)(n.code,{children:"dns-catcher"}),". This is a simple service that matches any IP address (0.0.0.0/0) and has a destination protocol and port of UDP/53. Our ",(0,i.jsx)(n.code,{children:"dns-catcher"})," service is set to allow the ",(0,i.jsx)(n.code,{children:"lan-clients"})," tenant (which is assigned to the LAN ",(0,i.jsx)(n.code,{children:"network-interface"}),"), so any traffic arriving on this interface destined for UDP/53 will be detoured to the DNS cache."]}),"\n",(0,i.jsxs)(n.p,{children:["The DNS cache will either respond locally (if there's an existing cache entry), or will forward the request to an upstream resolver. For the latter case, it will reenter the SSR's forwarding plane via the KNI interface (a.k.a. the \"service function chain\" interface) and be affiliated with the ",(0,i.jsx)(n.code,{children:"tenant"})," named ",(0,i.jsx)(n.code,{children:"dns-cache-plugin"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Once in the SSR's data plane, this traffic will match the ",(0,i.jsx)(n.code,{children:"internet"})," service (we've added an ",(0,i.jsx)(n.code,{children:"allow"})," statement for the ",(0,i.jsx)(n.code,{children:"dns-cache-plugin"})," tenant), and be forwarded out to the upstream server(s)."]}),"\n",(0,i.jsx)(n.h3,{id:"custom-dns-servers",children:"Custom DNS Servers"}),"\n",(0,i.jsxs)(n.p,{children:["To configure custom server addresses for dnsmasq instead of the ones affiliated with the host machine that the plugin is running on, add the ",(0,i.jsx)(n.code,{children:"addresses"})," field:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"dns-cache\n    enabled          true\n    addresses        1.1.1.1\n    addresses        2.2.2.2\n    tenant           dns-cache-plugin\n    ingress-service  dns-catcher\nexit\n"})}),"\n",(0,i.jsx)(n.h3,{id:"redirecting-and-blocking-domains",children:"Redirecting and blocking domains"}),"\n",(0,i.jsx)(n.h5,{id:"version-history",children:"Version History"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Release"}),(0,i.jsx)(n.th,{children:"Modification"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"1.1.0, 2.1.0"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"dns-cache > redirect-domains"})," and ",(0,i.jsx)(n.code,{children:"dns-cache > block-domains"})," were introduced"]})]})})]}),"\n",(0,i.jsx)(n.p,{children:"The DNS cache plugin will send all requests it processes to the list of servers provided in its configuration. Generally, these are configured as public DNS servers. However, many enterprises commonly host their own authoritative name server for their own domain (e.g., some-private-domain.com). The redirect-domains configuration lets administrators specify a distinct DNS server for a given domain, and SSR will use this when issuing queries for any host within that domain."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-config",children:"config\n\n    authority\n\n        router  router1\n            name       router1\n\n            dns-cache\n                enabled true\n                tenant dns-cache-plugin\n                ingress-service dns-catcher\n\n                redirect-domains  some-private-domain.com\n                    domain   some-private-domain.com\n                    address  192.168.8.8\n                exit\n                block-domains     block-domain.com\n            exit\n        exit\n    exit\nexit\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"block-domains"})," configuration allows the DNS server to block those domains by replying back with NXDOMAIN indicating that the domain name doesn't exist."]}),"\n",(0,i.jsx)(n.h3,{id:"custom-options",children:"Custom Options"}),"\n",(0,i.jsx)(n.h5,{id:"version-history-1",children:"Version History"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Release"}),(0,i.jsx)(n.th,{children:"Modification"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"3.3.1"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"dns-cache > custom-options"})," was introduced"]})]})})]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"custom-options"})," allows the user to configure additional dnsmasq options that are not exposed as support configuration options."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-config",metastring:"{10-13}",children:"config\n\n    authority\n\n        router  router\n            name       router\n\n            dns-cache\n\n                custom-options  domain-needed\n                    name   domain-needed\n                    value  yes\n                exit\n            exit\n        exit\n    exit\nexit\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Config"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"name"}),(0,i.jsx)(n.td,{children:"The name of the dnsmasq option"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"value"}),(0,i.jsx)(n.td,{children:"The value of the option"})]})]})]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"custom-option"})," is added to the dnsmasq config file; any invalid option could prevent the application from starting up."]})}),"\n",(0,i.jsx)(n.h2,{id:"third-party-software-and-licenses",children:"Third Party Software and Licenses"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"dnsmasq (GNU GPL v2, v3)"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,i.jsx)(n.p,{children:"To verify that the services are running properly on the SSR router:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"systemctl status 128T-dns-cache-forwarder.service"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"systemctl status 128T-dns-cache-matcher.service"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Verify that the dns-cache network interface (default ",(0,i.jsx)(n.code,{children:"dns-cache-intf"}),") is UP."]}),"\n",(0,i.jsx)(n.h2,{id:"release-notes",children:"Release Notes"}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["The plugin must be updated to version 3.2.1 or later prior to ",(0,i.jsx)(n.a,{href:"/docs/intro_upgrade_considerations#plugin-configuration-generation-changes",children:"upgrading the conductor to SSR version 5.4.0."})]})}),"\n",(0,i.jsx)(n.h3,{id:"release-350",children:"Release 3.5.0"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Release Date:"})," Dec 21, 2023"]}),"\n",(0,i.jsx)(n.h4,{id:"new-features-and-improvements",children:"New Features and Improvements"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PLUGIN-1842"})," Reduce Conductor CPU time to apply salt states in large scale deployments"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"By using Saltstack data files, the time to apply high states across all assets is significantly reduced"}),"\n",(0,i.jsx)(n.h3,{id:"release-340",children:"Release 3.4.0"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Release Date:"})," May 13, 2022"]}),"\n",(0,i.jsx)(n.h4,{id:"new-features-and-improvements-1",children:"New Features and Improvements"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PLUGIN-1611"})," Improve HA support for DNS based app-id"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The DNS cache plugin is enhanced to synchronize the cache between HA nodes to allow the DNS app-id plugin to consume and process DNS records on both nodes."}),"\n",(0,i.jsx)(n.h3,{id:"release-331",children:"Release 3.3.1"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Release Date:"})," Apr 29, 2022"]}),"\n",(0,i.jsx)(n.h4,{id:"new-features-and-improvements-2",children:"New Features and Improvements"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PLUGIN-1208"})," Enhance DNS Cache Plugin with An Advanced field"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Added support for new custom dnsmasq options that are otherwise not provided via direct configuration."}),"\n",(0,i.jsx)(n.h4,{id:"issues-fixed",children:"Issues Fixed"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"PLUGIN-1707"})," dns-cache service stops working"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Resolution:"})})," The salt states were made more robust to handle certain failure conditions better. In addition, the router will monitor the status of the dns service and restart it as necessary."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"release-322",children:"Release 3.2.2"}),"\n",(0,i.jsx)(n.h4,{id:"issues-fixed-1",children:"Issues Fixed"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"PLUGIN-1452"})," The dns-app-id plugin has lot of failures on system startup"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Resolution:"})})," The dns-app-id plugin will wait for dns-cache components to be initialized and running before starting up"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"PLUGIN-1480"})," Large configuration was causing plugin config generation to fail"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Resolution:"})})," The config generation logic for the plugin will handle config with long lines correctly"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"release-321",children:"Release 3.2.1"}),"\n",(0,i.jsx)(n.h4,{id:"issues-fixed-2",children:"Issues Fixed"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"PLUGIN-1461"}),"  Config generation for the plugin failing in the Bonsai mode"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Resolution:"})})," Correctly handle the config generation for routers where the DNS cache plugin is not enabled during bonsai config generation"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"PLUGIN-1367"}),"  DNS cache services constantly fail on system startup"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Resolution:"})})," The DNS cache systemd services will be deferred until the SSR services are running and stable."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"release-310",children:"Release 3.1.0"}),"\n",(0,i.jsx)(n.h4,{id:"issues-fixed-3",children:"Issues Fixed"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PLUGIN-768"})," Support the DNS Cache plugin in SSR versions ",(0,i.jsx)(n.code,{children:"5.1.0"})," and greater."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"release-120-220",children:"Release 1.2.0, 2.2.0"}),"\n",(0,i.jsx)(n.h4,{id:"issues-fixed-4",children:"Issues Fixed"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"PLUGIN-952"})," FIB entry for dns-app-id based applications was deleted before the advertised TTL causing traffic to be blackholed"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Resolution:"})})," The TTL value advertised to the clients is made configurable and is also set to 1500 seconds by default to match the internal DNS cache timers."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"release-110-210",children:"Release 1.1.0, 2.1.0"}),"\n",(0,i.jsx)(n.h4,{id:"new-features-and-improvements-3",children:"New Features and Improvements"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PLUGIN-641"})," Provide support for redirecting and blocking domains"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Added support for redirecting domains to a different upstream domain server. In addition, added support for blocking domains that the user should not be able to access."}),"\n",(0,i.jsx)(n.h4,{id:"issues-fixed-5",children:"Issues Fixed"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"PLUGIN-684"})," DNS cache plugin fails to apply configuration on initial installation"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Resolution:"})})," Make config handling on the router dependent on a successful plugin router RPM installation."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"release-101-201",children:"Release 1.0.1, 2.0.1"}),"\n",(0,i.jsx)(n.h4,{id:"issues-fixed-6",children:"Issues Fixed"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PLUGIN-402"})," Ensure the application restarts with SSR"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>l});var i=s(96540);const t={},r=i.createContext(t);function d(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);