"use strict";(self.webpackChunk_128t_docs=self.webpackChunk_128t_docs||[]).push([[655],{10206:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var i=t(74848),s=t(28453);const o={title:"Linux Host Networking Through SSR",sidebar_label:"Linux Host Networking"},r=void 0,a={id:"concepts_linux_host_networking",title:"Linux Host Networking Through SSR",description:"The SSR software is a set of daemons (processes) that run within a Linux operating system. There are many standard Linux components leveraged by SSR (e.g., NTP, sshd, dnf, etc.) that require network access. These components (hereafter referred to as host components) will send traffic via Linux's routing table unless instructed otherwise. This document describes the best practice for routing that traffic from the underlying Linux host operating system into the SSR routing domain, for subsequent traffic forwarding using the SSR paradigm.",source:"@site/docs/concepts_linux_host_networking.md",sourceDirName:".",slug:"/concepts_linux_host_networking",permalink:"/docs/concepts_linux_host_networking",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1710452559,formattedLastUpdatedAt:"Mar 14, 2024",frontMatter:{title:"Linux Host Networking Through SSR",sidebar_label:"Linux Host Networking"},sidebar:"docs",previous:{title:"Kernel Network Interfaces",permalink:"/docs/concepts_kni"},next:{title:"Learning VRF Routes",permalink:"/docs/concepts_learning_VRF_routes"}},c={},d=[{value:"Basic Configuration",id:"basic-configuration",level:2},{value:"Advanced Configuration",id:"advanced-configuration",level:3},{value:"KNI VLAN",id:"kni-vlan",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The SSR software is a set of daemons (processes) that run within a Linux operating system. There are many standard Linux components leveraged by SSR (e.g., NTP, sshd, dnf, etc.) that require network access. These components (hereafter referred to as ",(0,i.jsx)(n.em,{children:"host components"}),") will send traffic via Linux's routing table unless instructed otherwise. This document describes the best practice for routing that traffic from the underlying Linux host operating system into the SSR routing domain, for subsequent traffic forwarding using the SSR paradigm."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"When running on the host platform, the SSR has its own routing table in addition to the one that is running within Linux."})}),"\n",(0,i.jsx)(n.p,{children:"This document applies specifically to SSR routers. The SSR conductor does not require any special configuration to affect Linux host networking, since it does not forward packets using any technique other than Linux host networking to begin with."}),"\n",(0,i.jsx)(n.h2,{id:"basic-configuration",children:"Basic Configuration"}),"\n",(0,i.jsxs)(n.p,{children:["To forward traffic between Linux and SSR, we will use an interface type known as a ",(0,i.jsxs)(n.a,{href:"/docs/concepts_kni",children:[(0,i.jsx)(n.em,{children:"Kernel Network Interface"}),", or KNI"]}),". This is used to connect userspace applications with kernel networking."]}),"\n",(0,i.jsxs)(n.p,{children:['By default, the SSR creates a KNI interface ("kni254") that is used to route packets to Linux as part of its ',(0,i.jsx)(n.em,{children:"host-service"})," configuration. (A host-service is configured on a network-interface, and is used to forward various traffic types such as SSH and HTTP/HTTPS to Linux applications.) This kni254 interface is, by default, only used for inbound traffic (from Linux to the SSR) for host-services. By following the steps below, we can leverage the kni254 interface to send outbound traffic to the SSR."]}),"\n",(0,i.jsxs)(n.p,{children:["Create services (or modify existing services) for network access, adding an ",(0,i.jsx)(n.code,{children:"access-policy"})," that permits the tenant ",(0,i.jsx)(n.code,{children:"_internal_"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"_internal_"})," tenant is associated with all inbound requests arriving from Linux to SSR via kni254."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'service  internet\n    name                  internet\n    description           "internet reachability"\n    scope                 private\n    security              internal\n    address               0.0.0.0/0\n       \n    access-policy         guest\n        source      guest\n        permission  allow\n    exit\n    access-policy         trusted\n        source      trusted\n        permission  allow\n    exit\n    access-policy         _internal_\n        source      _internal_\n        permission  allow\n    exit\n    share-service-routes  false\nexit\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["Traffic originating from Linux and traveling through a KNI interface will have a source address of 169.254.127.127, which is a ",(0,i.jsx)(n.em,{children:"link-local"})," address. You must ensure that ",(0,i.jsx)(n.code,{children:"source-nat"})," is enabled on the egress interface used to carry this traffic out of the SSR platform."]})}),"\n",(0,i.jsx)(n.h3,{id:"advanced-configuration",children:"Advanced Configuration"}),"\n",(0,i.jsxs)(n.p,{children:["If you want to selectively forward via SSR, you can edit  ",(0,i.jsx)(n.code,{children:"/etc/sysconfig/network-scripts/route-kni254"})," from its default route of  ",(0,i.jsx)(n.code,{children:"0.0.0.0/0"})," with any address/prefix you wish. Additionally, you can edit the ",(0,i.jsx)(n.code,{children:"route-kni254"})," file to contain as many individual route statements as you like; it is important to only edit this file while the SSR is stopped, however, since it will cache the contents of the file when it starts, and restore the copy it cached when software is stopped."]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Stop the SSR software on the router. There are many ways to accomplish this, one of which is to type ",(0,i.jsx)(n.code,{children:"sudo systemctl stop 128T"})," from the Linux shell prompt."]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"You must ensure you are in a position to access the Linux subsystem on an SSR router even when the SSR software is not running."})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsxs)(n.li,{children:["Add a route to the internet in a route file associated with ",(0,i.jsx)(n.code,{children:"kni254"})," (the following should all be typed on one line):"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"sudo echo 0.0.0.0/0 via 169.254.127.126 dev kni254 metric 200 > /etc/sysconfig/network-scripts/route-kni254\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsxs)(n.li,{children:["Start the SSR software: ",(0,i.jsx)(n.code,{children:"sudo systemctl start 128T"})]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"/docs/plugin_loopback_static_routes#make-kni254-the-default-route-in-linux",children:"loopback-static-route plugin"})," can be installed and enabled on the SSR router to dynamically manage Linux routes."]})}),"\n",(0,i.jsx)(n.h3,{id:"kni-vlan",children:"KNI VLAN"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"host"})," device-interface can be configured with a vlan-enabled network interface.  Doing so creates a unique linux interface that is managed for each network-interface, but only one underlying KNI will be created on the system. If there is no non-vlan network-interface on the device-interface, an implicit underlying \u201cbase\u201d interface is instantiated for the KNI, and linux VLAN interfaces are stacked on it."]}),"\n",(0,i.jsx)(n.p,{children:"Output reflecting KNI interfaces with a VLAN of 200 configured:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"admin@t124-dut1.Fabric128# show device-interface\nSat 2019-02-16 18:45:18 UTC\n\n========================================\n t124-dut1:dev12\n========================================\n Type:                host\n Forwarding:          true\n Mode:                host\n MAC Address:         b2:9c:1f:9a:d9:7a\n\n Admin Status:        up\n Operational Status:  up\n Redundancy Status:   non-redundant\n Speed:               1000\n\n in-octets:                        2816\n in-unicast-pkts:                    38\n in-errors:                           0\n out-octets:                          0\n out-unicast-pkts:                    0\n out-errors:                          0\n\n network-interfaces:\n   dev12:\n     base state:      good\n   dev12.200:\n     vlan state:      good\n\nCompleted in 0.24 seconds\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"admin@t124-dut1.Fabric128# show platform device-interfaces\nSat 2019-02-16 18:45:56 UTC\n\n===============================================================\n t124-dut1\n===============================================================\n ----------------------------\n Device Interface Information\n ----------------------------\n\n Name:                     dev12\n Manufacturer:\n Description:\n Driver:\n Driver Version:           unavailable\n Speed:\n PCI Address:\n MAC Address:              be:0c:c2:1e:79:be\n Firmware Version:         unavailable\n Statistics Supported:     unavailable\n Test Info Supported:      unavailable\n EEPROM Access Supported:  unavailable\n Register Dump Supported:  unavailable\n network-interfaces:\n   dev12:\n     base info:            good\n   dev12.200:\n     vlan info:            good\n\nCompleted in 1.29 seconds\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(96540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);