"use strict";(self.webpackChunk_128t_docs=self.webpackChunk_128t_docs||[]).push([[5542],{73035:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var t=i(74848),s=i(28453);const r={title:"Kernel Network Namespace Scripts",sidebar_label:"KNI Namespace Scripts"},o=void 0,a={id:"plugin_kni_namespace_scripts",title:"Kernel Network Namespace Scripts",description:"As part of plugin development to extend the functionality of an SSR, a very common model is to leverage KNI (Kernel Network Interface) along with Linux network namespaces. They allow for isolation of various networking components such as interfaces, routing table, iptables, etc., while running applications that leverage these networking namespaces. This is also very common method to deploy Service Function Chaining within the product.",source:"@site/docs/plugin_kni_namespace_scripts.md",sourceDirName:".",slug:"/plugin_kni_namespace_scripts",permalink:"/docs/plugin_kni_namespace_scripts",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1710958440,formattedLastUpdatedAt:"Mar 20, 2024",frontMatter:{title:"Kernel Network Namespace Scripts",sidebar_label:"KNI Namespace Scripts"},sidebar:"docs",previous:{title:"Wireguard",permalink:"/docs/plugin_wireguard"},next:{title:"6.2",permalink:"/docs/release_notes_128t_6.2"}},c={},l=[{value:"Scripts",id:"scripts",level:2},{value:"startup",id:"startup",level:3},{value:"init",id:"init",level:3},{value:"reinit",id:"reinit",level:3},{value:"shutdown",id:"shutdown",level:3},{value:"Installation",id:"installation",level:3},{value:"Symlink To KNI scripts",id:"symlink-to-kni-scripts",level:3},{value:"Configuration",id:"configuration",level:2},{value:"Variable Substitution",id:"variable-substitution",level:3},{value:"Target Definition",id:"target-definition",level:3},{value:"Application Definition",id:"application-definition",level:3},{value:"Routing Definition",id:"routing-definition",level:3},{value:"Usage",id:"usage",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["As part of plugin development to extend the functionality of an SSR, a very common model is to leverage ",(0,t.jsx)(n.a,{href:"/docs/concepts_kni",children:"KNI (Kernel Network Interface)"})," along with Linux network namespaces. They allow for isolation of various networking components such as interfaces, routing table, iptables, etc., while running applications that leverage these networking namespaces. This is also very common method to deploy ",(0,t.jsx)(n.a,{href:"/docs/plugin_intro#service-function-chaining",children:"Service Function Chaining"})," within the product."]}),"\n",(0,t.jsx)(n.p,{children:"The goal of this package is to provide a set of scripts which do most of the tasks when it comes to setting up the namespaces and associated environment."}),"\n",(0,t.jsx)(n.h2,{id:"scripts",children:"Scripts"}),"\n",(0,t.jsxs)(n.p,{children:["The following scripts are part of the package and have a well-defined role as described ",(0,t.jsx)(n.a,{href:"/docs/concepts_kni#script-types",children:"here"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"startup",children:"startup"}),"\n",(0,t.jsxs)(n.p,{children:["This script is invoked at the beginning of the KNI creation and is intended to do clean-up. In the current implementation this script will stop the configured ",(0,t.jsx)(n.a,{href:"#application-definition",children:"application"})," (if any)."]}),"\n",(0,t.jsx)(n.h3,{id:"init",children:"init"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"/docs/concepts_kni#init",children:"init script"})," is responsible for the majority of the setup. The script performs the following high-level function:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Create the configured network-namespace in Linux as per SSR requirements."}),"\n",(0,t.jsx)(n.li,{children:"Move and setup any configured target-interface into the namespace"}),"\n",(0,t.jsx)(n.li,{children:"Tune common parameters within the namespace such as ip-forwarding, arp-proxy, etc."}),"\n",(0,t.jsx)(n.li,{children:"Start any configured application(s) within the namespace"}),"\n",(0,t.jsx)(n.li,{children:"Setup routes and iptable rules"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"reinit",children:"reinit"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"/docs/concepts_kni#reinit",children:"reinit"})," script is called when the interface is deemed to be down for more than 10 seconds. For the sake of this implementation we simply symlink the ",(0,t.jsx)(n.code,{children:"reinit"})," to ",(0,t.jsx)(n.code,{children:"init"})," script"]}),"\n",(0,t.jsx)(n.h3,{id:"shutdown",children:"shutdown"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"/docs/concepts_kni#shutdown",children:"shutdown"})," script is called during SSR shutdown or deletion of the interface. This script will stop the configured ",(0,t.jsx)(n.a,{href:"#application-definition",children:"application"})," (if any) and delete the network namespace"]}),"\n",(0,t.jsx)(n.h3,{id:"installation",children:"Installation"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"t128-kni-namespace-scripts"})," package contains all the scripts mentioned ",(0,t.jsx)(n.a,{href:"#scripts",children:"above"}),". Upon installation, the scripts in this package are placed under ",(0,t.jsx)(n.code,{children:"/etc/128technology/plugins/network-scripts/default/kni_namespace/"})," with the right set of permissions and settings required for operation by the SSR."]}),"\n",(0,t.jsx)(n.h3,{id:"symlink-to-kni-scripts",children:"Symlink To KNI scripts"}),"\n",(0,t.jsxs)(n.p,{children:["The package only contains a subset of the scripts provided by the ",(0,t.jsx)(n.a,{href:"/docs/concepts_kni#script-types",children:"network-script design"}),". There are other scripts such as state, info, monitoring, etc., which are not covered in this package. As a result, the best practice is to symlink the host KNI scripts to the pre-packaged scripts listed ",(0,t.jsx)(n.a,{href:"#scripts",children:"above"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, for a configuration with a ",(0,t.jsx)(n.code,{children:"host"})," kni called ",(0,t.jsx)(n.code,{children:"test-sfc"})," the scripts above would be used as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-console",children:"# ll /etc/128technology/plugins/network-scripts/host/test-sfc/\ntotal 0\nlrwxrwxrwx 1 root root 69 Jan 21 04:09 init -> /etc/128technology/plugins/network-scripts/default/kni_namespace/init\nlrwxrwxrwx 1 root root 71 Jan 21 04:09 reinit -> /etc/128technology/plugins/network-scripts/default/kni_namespace/reinit\nlrwxrwxrwx 1 root root 73 Jan 21 04:09 shutdown -> /etc/128technology/plugins/network-scripts/default/kni_namespace/shutdown\nlrwxrwxrwx 1 root root 72 Jan 21 04:09 startup -> /etc/128technology/plugins/network-scripts/default/kni_namespace/startup\n"})}),"\n",(0,t.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,t.jsxs)(n.p,{children:["A YAML based configuration is used to control various aspects of the KNIs and namespaces that are driven through this scripts. The configuration file is optional and the scripts will still perform the basic tasks as described ",(0,t.jsx)(n.a,{href:"#scripts",children:"above"}),". The scripts looks for a file called ",(0,t.jsx)(n.code,{children:"<kni-name>.conf"})," under ",(0,t.jsx)(n.code,{children:"/var/lib/128technology/kni/host/"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'target-interface:\n    name: "eth0"\n    ip-address: "10.10.20.10"\n    prefix-length: 24\n    gateway: "10.10.20.11"\n    default-route: True\napplication:\n    startup:\n        - "ifup test-tun0"\n    shutdown:\n        - "ifdown test-tun0"\nrouting:\n    - "default dev test-tun0"\nroute-tables:\n    default:\n        routes:\n            - "default dev test-tun0"\n    gre:\n        table-id: 1024\n        ingress-interface: t0\n        routes:\n        - "default dev kni345"\n'})}),"\n",(0,t.jsx)(n.p,{children:"The above example shows all the possible configuration. All of these configuration are optional and reasonable defaults are assumed. Each of the sections below discuss the options in more details."}),"\n",(0,t.jsx)(n.h3,{id:"variable-substitution",children:"Variable Substitution"}),"\n",(0,t.jsxs)(n.p,{children:["The configuration supports basic variable substitutions which directly map to the ",(0,t.jsx)(n.a,{href:"/docs/concepts_kni#script-command-line-arguments",children:"arguments passed to the network-scripts"})," by SSR. The following keywords can be used in the config and will be substituted with the correct arguments at runtime."]}),"\n",(0,t.jsx)(n.p,{children:"Consider the following configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-config",children:"device-interface\n    name test\n    type host\n    network-namespace test-ns\n    network-interface\n        name test-intf\n        global-id  5\n        address\n            ip-address 169.254.140.1\n            prefix-length 30\n            gateway 169.254.140.2\n"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Variable"}),(0,t.jsx)(n.th,{children:"Meaning"}),(0,t.jsx)(n.th,{children:"Config Example"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"{kni_interface}"})}),(0,t.jsx)(n.td,{children:"Name of the KNI interface"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"test"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"{namespace}"})}),(0,t.jsx)(n.td,{children:"Name of the namespace the KNI belongs to (including the namespace-id)"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"testns:1073741829"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"{kni_ip}"})}),(0,t.jsxs)(n.td,{children:["Configured IP address for the KNI interface (corresponds to ",(0,t.jsx)(n.code,{children:"address > gateway"})]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"169.254.140.2"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"{kni_prefix_length}"})}),(0,t.jsxs)(n.td,{children:["Configured prefix-length for the KNI interface (corresponds to ",(0,t.jsx)(n.code,{children:"address > prefix-length"})]}),(0,t.jsx)(n.td,{children:"30"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"{kni_gateway}"})}),(0,t.jsxs)(n.td,{children:["Configured gateway address for the KNI interface (corresponds to ",(0,t.jsx)(n.code,{children:"address > ip-address"})]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"169.254.140.1"})})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"The following YAML configurations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'routing:\n    - "default dev {kni_interface} via {kni_gateway}"\n'})}),"\n",(0,t.jsx)(n.p,{children:"will therefore be converted to the following at runtime:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'routing:\n    - "default dev test via 169.254.140.1"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"target-definition",children:"Target Definition"}),"\n",(0,t.jsxs)(n.p,{children:["This configuration allows for another interface to be configured as part of the namespace. This is usually an interface in Linux which is used for forwarding the traffic through to an endpoint. Only a ",(0,t.jsx)(n.code,{children:"single"})," target interface can be configured and it's optional. The following snippet shows an example of setting parameters for the ",(0,t.jsx)(n.code,{children:"target-interface"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'target-interface:\n    name: "eth0"\n    ip-address: "10.10.20.10"\n    prefix-length: 24\n    gateway: "10.10.20.11"\n    default-route: True\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"default-route"})," flag is used to set the target-interface as a ",(0,t.jsx)(n.code,{children:"default"})," route with zero metric in the namespace making it the preferred choice for routing all traffic."]}),"\n",(0,t.jsx)(n.h3,{id:"application-definition",children:"Application Definition"}),"\n",(0,t.jsxs)(n.p,{children:["Any ",(0,t.jsx)(n.a,{href:"/docs/plugin_intro#service-function-chaining",children:"SFC application"})," will require some applications to run within the namespace to consume the KNI and other network resources. This configuration provides a list of commands to be run within the namespace."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["The scripts will automatically append ",(0,t.jsx)(n.code,{children:"ip netns exec"})," for every configured command."]})}),"\n",(0,t.jsx)(n.p,{children:"This configuration is optional. Consider this example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'application:\n    startup:\n        - "ifup test-tun0"\n    shutdown:\n        - "ifdown test-tun0"\n'})}),"\n",(0,t.jsx)(n.p,{children:"In this case, the user can configure the logic to start and stop applications as needed."}),"\n",(0,t.jsx)(n.h3,{id:"routing-definition",children:"Routing Definition"}),"\n",(0,t.jsxs)(n.p,{children:["It's useful to be able to influence the basic routing rules within the namespace. The ",(0,t.jsx)(n.code,{children:"routing"})," config in its simplest form can be used to add routes to the default routing table. For most applications this is sufficient and acts as a way to create quick configuration of routes. For example"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'routing:\n    - "192.168.0.0/16 via 169.254.140.1 dev test"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The above example, will create a single route table entry for the prefix ",(0,t.jsx)(n.code,{children:"192.168.0.0/16"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"If a target interface is configured as default-route and no routing rules are specified, a default route for the target will be added."})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"routing definition"})," section will override any other routes specified elsewhere in the config"]})}),"\n",(0,t.jsxs)(n.p,{children:["For a more advanced use case, such as tunneling or NAT, a single routing table is not enough. For such applications, a ",(0,t.jsx)(n.code,{children:"route-tables"})," definition can be used. The ",(0,t.jsx)(n.code,{children:"route-tables"})," allow the user to do the following:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Create a new routing table in the namespace"}),"\n",(0,t.jsx)(n.li,{children:"Specify the conditions under which to use this routing table"}),"\n",(0,t.jsx)(n.li,{children:"Create rules to be used for this new table."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'route-tables:\n    default:\n        routes:\n            - "default dev test-tun0"\n    gre:\n        table-id: 1024\n        ingress-interface: t0\n        routes:\n        - "default dev kni345"\n\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"default"})," keyword is used to create route entries for the default route table in Linux. In the above example, the second entry for ",(0,t.jsx)(n.code,{children:"gre"})," table will create a new table with the identifier ",(0,t.jsx)(n.code,{children:"1024"}),". For each route-table, the user can configure the conditions and parameters for which the table can be used. These parameters translate to the options for the ",(0,t.jsx)(n.code,{children:"ip rules add"})," command. The currently supported parameters include"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"ingress-interface (iif)"}),"\n",(0,t.jsx)(n.li,{children:"egress-interface (off)"}),"\n",(0,t.jsx)(n.li,{children:"from-prefix (from)"}),"\n",(0,t.jsx)(n.li,{children:"to-prefix (to)"}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["The rules defined under ",(0,t.jsx)(n.code,{children:"routing"})," will be applied before any ",(0,t.jsx)(n.code,{children:"route-tables"}),". Since the ",(0,t.jsx)(n.code,{children:"route-tables"})," supersede the functionality of ",(0,t.jsx)(n.code,{children:"routing"})," it is not recommended to use both in the same config."]})}),"\n",(0,t.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,t.jsx)(n.p,{children:"In order to leverage these scripts, the user has to do at most two things:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#symlink-to-kni-scripts",children:"Symlink to the kni scripts"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#configuration",children:"Configure various aspects of the pre-packaged scripts"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(96540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);