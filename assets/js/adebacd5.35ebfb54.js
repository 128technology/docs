"use strict";(self.webpackChunk_128t_docs=self.webpackChunk_128t_docs||[]).push([[3784],{81311:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>h});var n=o(74848),s=o(28453);const a={title:"Forwarding Information Base (FIB) - Concepts",sidebar_label:"FIB Concepts"},r=void 0,i={id:"concepts_fib",title:"Forwarding Information Base (FIB) - Concepts",description:"The SSR is a session-based router, and makes forwarding decisions based on the first packet of a flow. All subsequent packets follow the same path through the SSR fabric as the first packet, except when network events dictate that a session must be reevaluated to allow the packets to follow a different path. These decisions are made by the service area code. This code consults a table known as the Forwarding Information Base (FIB) to make these decisions.",source:"@site/docs/concepts_fib.md",sourceDirName:".",slug:"/concepts_fib",permalink:"/docs/concepts_fib",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Forwarding Information Base (FIB) - Concepts",sidebar_label:"FIB Concepts"},sidebar:"docs",previous:{title:"Glossary",permalink:"/docs/concepts_glossary"},next:{title:"How the FIB is Constructed",permalink:"/docs/concepts_fib_construction"}},c={},h=[{value:"What is a FIB Entry?",id:"what-is-a-fib-entry",level:2},{value:"How FIB Lookups Are Made",id:"how-fib-lookups-are-made",level:3},{value:"Results of FIB lookups",id:"results-of-fib-lookups",level:3}];function l(e){const t={admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["The SSR is a session-based router, and makes forwarding decisions based on the first packet of a flow. All subsequent packets follow the same path through the SSR fabric as the first packet, except when network events dictate that a session must be reevaluated to allow the packets to follow a different path. These decisions are made by the ",(0,n.jsx)(t.strong,{children:"service area"})," code. This code consults a table known as the Forwarding Information Base (FIB) to make these decisions."]}),"\n",(0,n.jsx)(t.p,{children:"To minimize delay when forwarding packets, this table requires a fast lookup. To optimize memory usage for the FIB table and other tables used in packet forwarding operations, a portion of the system RAM is set aside as Linux hugepages. Hugepages are allocated and reserved for the FIB tables at system boot time. The amount of memory allocated to hugepages and the number of entries for each table are automatically calculated during initialization of the SSR software based on the amount of RAM present. It is possible to dedicate more system memory to hugepages and to change the number of entries available for each table. However, because doing so will reduce the RAM available for other OS processes, this change should only be carried out at the direction of SSR support."}),"\n",(0,n.jsx)(t.h2,{id:"what-is-a-fib-entry",children:"What is a FIB Entry?"}),"\n",(0,n.jsxs)(t.p,{children:["A FIB entry consists of several key values used as a lookup to determine how to apply policy for a new session. The ",(0,n.jsx)(t.strong,{children:"values"})," used as lookup parameters are: IP prefix, protocol, port number, and tenant. The ",(0,n.jsx)(t.strong,{children:"results"})," of a FIB entry lookup are the service, next-hops, vector, and cost. An example of a single FIB entry is shown below."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"==================== =========== ======= ========== ===== ========================= ============= ======== ======\n IP Prefix                 Port   Proto   Tenant     VRF   Service                   Next Hops     Vector   Cost\n==================== =========== ======= ========== ===== ========================= ============= ======== ======\n10.1.1.0/24                  0   None    t0         -     s0                        192.168.1.2   -        0\n\n"})}),"\n",(0,n.jsx)(t.h3,{id:"how-fib-lookups-are-made",children:"How FIB Lookups Are Made"}),"\n",(0,n.jsxs)(t.p,{children:["When a packet arrives at the SSR, regardless of whether the packet arrives over SVR or is natively routed to an interface, the packet is first classified as belonging to a ",(0,n.jsx)(t.strong,{children:"tenant"}),". The tenant is part of the lookup key for the FIB. If there is no tenant match for the packet (either due to lack of an explicitly configured tenant on an interface, or due to a source address not matching a configured tenant-prefix mapping), the packet is classified as belonging to the ",(0,n.jsx)(t.code,{children:"<global>"})," tenant. When matching a packet of a new session to the FIB table, only FIB entries for the classified tenant are considered."]}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsxs)(t.p,{children:["A note on the ",(0,n.jsx)(t.code,{children:"<global>"})," tenant: FIB entries for the ",(0,n.jsx)(t.code,{children:"<global>"})," tenant are only generated for services who have the ",(0,n.jsx)(t.code,{children:"scope"})," configuration option set to ",(0,n.jsx)(t.code,{children:"public"}),". This is roughly equivalent to creating an access-policy for the ",(0,n.jsx)(t.code,{children:"<global>"})," tenant. This does not automatically allow traffic for all tenants. If traffic classified as originating from another tenant needs to access a service, an access-policy for that tenant must also be configured on the service."]})}),"\n",(0,n.jsxs)(t.p,{children:["Once the tenant has been identified, the transport protocol and destination port of the packet are used as keys to lookup the best FIB entry match for the tenant. FIB entries that only specify a transport protocol without specific destination ports - shown as port zero (0) in the FIB - will match any destination port of a packet. Entries with a port of zero are treated as less specific than entries that contain an explicit port range. From the more specific entries (those with a configured port range) that match the destination port of the packet, the destination address is used in a ",(0,n.jsx)(t.strong,{children:"longest prefix match"})," (LPM) comparison. The most specific prefix that matches the destination address will be the selected entry. If there are no port-range specific entries that match the destination port of the packet, or if there is no valid prefix match, FIB entries with the transport protocol (but no configured port-range) of the packet will then be considered for an LPM comparison. If there are no entries with the destination protocol of the packet, or if none match the destination address of the packet in an LPM lookup, then entries that do not specify a protocol will be considered for an LPM lookup. If there is no match at this point, then a FIB miss is declared, and the session is not installed in the session table and no packets for the session will be forwarded."]}),"\n",(0,n.jsx)(t.p,{children:"The order of precedence for FIB lookup is as follows:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"FIB entry matches IP prefix, transport protocol, and destination port with a configured port range."}),"\n",(0,n.jsx)(t.li,{children:"FIB entry matches IP prefix and transport protocol."}),"\n",(0,n.jsx)(t.li,{children:"FIB entry matches IP prefix."}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"results-of-fib-lookups",children:"Results of FIB lookups"}),"\n",(0,n.jsx)(t.p,{children:"A FIB lookup either returns no match, or exactly one matching entry. For a session to be installed and traffic to be forwarded, the FIB must contain at least one next-hop. A valid next-hop may be a specific egress-interface, a next-hop gateway address, or an adjacency address for SVR traffic. There may be multiple next-hops for a single FIB entry. When looking at the FIB, the multiple next-hops may appear to be distinct FIB entries, but that is merely the way the FIB is displayed to the user. In the example below, Service s0 has two entries for the 10.0.0.0/8 prefix \u2013 one for tenant t0 and one for tenant t1. This service is configured with a service-route with two next-hops, one out interface wan1 and one out interface wan2."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"==================== =========== ======= ========== ===== ========================= ============= ======== ======\n IP Prefix                 Port   Proto   Tenant     VRF   Service                   Next Hops     Vector   Cost\n==================== =========== ======= ========== ===== ========================= ============= ======== ======\n 10.0.0.0/8                   0   None    t0         -     s0                        1-2.0         wan1     10\n                                                                                     1-3.0         wan2     100\n                                          t1         -     s0                        1-2.0         wan1     10\n                                                                                     1-3.0         wan2     100\n\n"})}),"\n",(0,n.jsxs)(t.p,{children:["From looking at the above output, it may appear that there are four entries. However, ",(0,n.jsx)(t.strong,{children:"additional next-hops do not create additional FIB entries"}),". The above output is considered to be two entries. If there are multiple next-hops available for the selected FIB entry, then the service-policy associated with the service of the matching FIB entry aids in selecting which one is used. This is typically based on vector priority, or traffic may be balanced across multiple paths with equal cost by the SSR\u2019s internal load balancer."]})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},28453:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>i});var n=o(96540);const s={},a=n.createContext(s);function r(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);