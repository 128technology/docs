"use strict";(self.webpackChunk_128t_docs=self.webpackChunk_128t_docs||[]).push([[9233],{1615:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var t=n(74848),r=n(28453);const s={title:"Service and Service Policy Design",sidebar_label:"Service and Service Policy Design"},o=void 0,a={id:"bcp_service_and_service_policy_design",title:"Service and Service Policy Design",description:"Designing a service-oriented network with the SSR benefits from careful planning and thoughtful policy decisions. With the ability to steer traffic using the best path on a per-session basis, administrators have more control than ever before in deciding how their users maximize the network. This document discusses two fundamental, and related concepts: the service and the service-policy.",source:"@site/docs/bcp_service_and_service_policy_design.md",sourceDirName:".",slug:"/bcp_service_and_service_policy_design",permalink:"/docs/bcp_service_and_service_policy_design",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Service and Service Policy Design",sidebar_label:"Service and Service Policy Design"},sidebar:"docs",previous:{title:"Saltstack at Scale With SSR",permalink:"/docs/bcp_salt_pillars"},next:{title:"Service Policy Baseline Defaults",permalink:"/docs/bcp_service-policy_defaults"}},c={},l=[{value:"Intended Audience",id:"intended-audience",level:2},{value:"Overview",id:"overview",level:2},{value:"Service Types",id:"service-types",level:2},{value:"Fully Qualified Services",id:"fully-qualified-services",level:3},{value:"CIDR Services",id:"cidr-services",level:3},{value:"Summary and Spoke Services",id:"summary-and-spoke-services",level:3},{value:"Generated Services",id:"generated-services",level:3},{value:"Router/Router Group-Based Services",id:"routerrouter-group-based-services",level:3},{value:"Application-Module Services",id:"application-module-services",level:3},{value:"Hierarchical Services",id:"hierarchical-services",level:3},{value:"Inherited Attributes of Hierarchical Services",id:"inherited-attributes-of-hierarchical-services",level:4},{value:"Template Services",id:"template-services",level:3},{value:"Service Policy",id:"service-policy",level:2},{value:"Vectors",id:"vectors",level:3},{value:"Session Resiliency",id:"session-resiliency",level:3},{value:"Session Failover",id:"session-failover",level:3},{value:"Path Quality Metrics",id:"path-quality-metrics",level:3},{value:"Transport State Enforcement",id:"transport-state-enforcement",level:3}];function d(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["Designing a service-oriented network with the SSR benefits from careful planning and thoughtful policy decisions. With the ability to steer traffic using the best path on a per-session basis, administrators have more control than ever before in deciding how their users maximize the network. This document discusses two fundamental, and related concepts: the ",(0,t.jsx)(i.em,{children:"service"})," and the ",(0,t.jsx)(i.em,{children:"service-policy"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["A service is a network destination of interest to your network's users. It can represent a web server, a PBX system for your phones, a CRM system in the public cloud, or something specific only to you. The ",(0,t.jsx)(i.code,{children:"service"}),' data model in the SSR modeling language gives administrators great flexibility in defining what constitutes an "interesting" application that requires specific treatment as contrasted to bulk data. The ',(0,t.jsx)(i.code,{children:"service-policy"})," affiliated with that ",(0,t.jsx)(i.code,{children:"service"})," lets the administrator specify the treatment for the traffic of that service: where it should go, which path it should use to get there, how it gets treated along the way (marked and queued), and what to do in the event of network failures."]}),"\n",(0,t.jsx)(i.p,{children:"In this document we will cover the various types of services that are configurable in the SSR data model, and how to apply them. We will then discuss the predominant service-policy options for governing the traffic treatment for traffic steering, and give some rules of thumb for how to apply them."}),"\n",(0,t.jsx)(i.h2,{id:"intended-audience",children:"Intended Audience"}),"\n",(0,t.jsxs)(i.p,{children:["This document is intended for network administrators and network architects responsible for designing SSR configurations for their end users. It provides a conceptual overview for the different options available for configuring ",(0,t.jsx)(i.code,{children:"service"})," and ",(0,t.jsx)(i.code,{children:"service-policy"})," data models, and guidance on when to use the various attributes."]}),"\n",(0,t.jsx)(i.p,{children:"This document is relevant to the day-to-day job of network operations and network support staff, to help them to interpret a configuration to understand its intent."}),"\n",(0,t.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(i.p,{children:["In the SSR worldview, each IP destination that will receive traffic must be configured as a ",(0,t.jsx)(i.em,{children:"service"}),". A service can be defined as broadly as a netmask (it is common for our customers to have a service representing the entire internet, as 0.0.0.0/0) or as specific as a transport protocol and single port. As traffic arrives at an SSR router, it (among other things) is associated with a configured service, which will in turn influence its path selection."]}),"\n",(0,t.jsx)(i.p,{children:"Path selection on the SSR is a decision process that considers several factors:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Current network state. Are next hops reachable? Is a remote peer reachable? What are the current quality metrics for the various potential paths?"}),"\n",(0,t.jsx)(i.li,{children:'Administrative priorities. Which path should this traffic take in the "sunny day scenario," when all paths are available? How should the SSR assess viability for a path for any given service?'}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["In the previous section of this document we discuss how the SSR determines whether or not a remote peer is reachable (asynchronous BFD) and the quality of the path (echo BFD). These both pertain to the ",(0,t.jsx)(i.em,{children:"current network state"}),". The ",(0,t.jsx)(i.em,{children:"administrative priorities"})," of the SSR are described through the use of a ",(0,t.jsx)(i.em,{children:"service-policy"}),", a configuration element that is associated with a service."]}),"\n",(0,t.jsx)(i.h2,{id:"service-types",children:"Service Types"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.em,{children:"service"})," configuration element is the cornerstone of the SSR data model. It is what allows administrators to describe eligible destinations for traffic, to which they can subsequently define access controls, routing policy, and traffic treatment. There is a strong correlation between successful deployments of the SSR software and a deep understanding of the services on the target network."]}),"\n",(0,t.jsx)(i.p,{children:"A service's configuration is very flexible, and can represent many different aspects of a network's topology. The various data modeling variants of a service are described in the sections that follow."}),"\n",(0,t.jsx)(i.h3,{id:"fully-qualified-services",children:"Fully Qualified Services"}),"\n",(0,t.jsxs)(i.p,{children:["The most fundamental, and granular definition of a service is one which defines a specific application on your network. The goal of any SSR-powered configuration should be to configure ",(0,t.jsx)(i.em,{children:"fully qualified"})," services with as much precision as possible. The key elements of a fully qualified service are:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"A narrow range of IP addresses that all serve the application"}),"\n",(0,t.jsx)(i.li,{children:"Specific transport protocols and ports that the application uses"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Example:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"admin@labsystem1.fiedler# show config running authority service cloudflare-dns\n\nconfig\n\n    authority\n\n        service  cloudflare-dns\n            name                  cloudflare-dns\n            scope                 private\n\n            transport             udp\n                protocol    udp\n\n                port-range  53\n                    start-port  53\n                exit\n            exit\n            address               1.1.1.1/32\n            address               1.0.0.1/32\n\n            access-policy         trusted\n                source  trusted\n            exit\n\n            access-policy         _internal_\n                source      _internal_\n                permission  allow\n            exit\n            share-service-routes  false\n        exit\n    exit\nexit\n"})}),"\n",(0,t.jsx)(i.admonition,{title:"Key to success",type:"tip",children:(0,t.jsx)(i.p,{children:"Define the service as specifically as possible, using transport/port and specific IP addresses as appropriate."})}),"\n",(0,t.jsx)(i.h3,{id:"cidr-services",children:"CIDR Services"}),"\n",(0,t.jsxs)(i.p,{children:["Many deployments of the SSR software include a number of ",(0,t.jsx)(i.em,{children:"CIDR services"})," which \u2013 in contrast to fully qualified services \u2013 are broad swaths of IP addresses, typically located behind an SSR at a specific location."]}),"\n",(0,t.jsx)(i.p,{children:"The hallmarks of a CIDR Service are that it seldom has transport protocols defined, and never has ports defined. (Administrators may configure transport protocols without ports to restrict a service to TCP, UDP, and ICMP only, and block other IP protocols such as GRE.)"}),"\n",(0,t.jsx)(i.p,{children:"Example:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"admin@labsystem1.fiedler# show config run auth service burlington-guest\n\nconfig\n\n    authority\n\n        service  burlington-guest\n            name           burlington-guest\n            scope          private\n            security       internal\n            address        172.18.32.0/20\n\n            access-policy  trusted\n                source      trusted\n                permission  allow\n            exit\n\n            access-policy  _internal_\n                source      _internal_\n                permission  allow\n            exit\n            source-nat     network-interface\n        exit\n    exit\nexit\n"})}),"\n",(0,t.jsx)(i.h3,{id:"summary-and-spoke-services",children:"Summary and Spoke Services"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"Summary services"})," and ",(0,t.jsx)(i.em,{children:"spoke services"}),' work in conjunction with each another to provide coarse routes from one SSR to another, and specific routes from the receiving SSR router to the destination. It is commonly used in "hub and spoke" topologies, where a less-specific route will direct traffic to a location, and that location\'s router has more specific routes to apply to the traffic.']}),"\n",(0,t.jsx)(i.p,{children:'For example, in a retail deployment it is common for each branch location to have a specific CIDR block allocated, e.g., 10.20.20.0/24 for "site 2020." For traffic originating in a data center and destined for the branch, a summary service is configured using the address 10.20.20.0/24. The branch router has more specific spoke services for the individual applications at the branch; e.g., 10.20.20.128/32, 10.20.20.60/32 UDP/5060, etc.'}),"\n",(0,t.jsxs)(i.p,{children:["Conceptually, summary services and spoke services are very similar to CIDR services and application-based services, respectively. However, there is one significant difference between a summary service and a CIDR service: the summary service ",(0,t.jsx)(i.em,{children:"must include a transport section"}),'. This is the "trigger" for the receiving SSR router to apply a more-specific spoke service.']}),"\n",(0,t.jsx)(i.admonition,{type:"note",children:(0,t.jsxs)(i.p,{children:["A second, common attribute of summary services is the inclusion of an ",(0,t.jsx)(i.code,{children:"applies-to"})," block in the configuration. The purpose of this block is described in more detail in the ",(0,t.jsx)(i.em,{children:"Router/Router Group-based Services"})," section below. Because summary and spoke services are generally at their most useful in massive deployments to reduce overall configuration overhead, this is a strong case for using Router/Router Group-based services whenever summary services are considered."]})}),"\n",(0,t.jsx)(i.p,{children:"Example:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"config\n\n    authority\n    \n        service            site2020_summary\n            name                  site2020_summary\n\n            applies-to            router-group\n                type        router-group\n                group-name  datacenters\n                group-name  retail-site2020\n            exit\n            security              internal\n\n            transport             tcp\n                protocol  tcp\n            exit\n\n            transport             udp\n                protocol  udp\n            exit\n\n            transport             icmp\n                protocol  icmp\n            exit\n            address               10.20.20.0/24\n\n            access-policy         datacenter\n                source  datacenter\n            exit\n            service-policy        core2store-retail\n            share-service-routes  true\n        exit\n    exit\nexit\n"})}),"\n",(0,t.jsx)(i.h3,{id:"generated-services",children:"Generated Services"}),"\n",(0,t.jsx)(i.p,{children:"Various features within the SSR will cause services to be generated automatically when configured. This includes:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Conductor Host Services"}),"\n",(0,t.jsx)(i.li,{children:"BGP over SVR"}),"\n",(0,t.jsx)(i.li,{children:"DHCP Relay"}),"\n"]}),"\n",(0,t.jsx)(i.admonition,{type:"note",children:(0,t.jsx)(i.p,{children:"The services generated by the SSR are created as fully qualified services."})}),"\n",(0,t.jsxs)(i.p,{children:["Each of these service types shares one important attribute: they are created with the ",(0,t.jsx)(i.code,{children:"generated"})," flag set to ",(0,t.jsx)(i.code,{children:"true"}),". If you want to make any modifications to the generated services, you must first set ",(0,t.jsx)(i.code,{children:"generated"})," to ",(0,t.jsx)(i.code,{children:"false"}),", or else your configuration changes will be stripped upon the next time the configuration is committed. For more information on configuration workflows involving the ",(0,t.jsx)(i.code,{children:"generated"})," flag, refer to the ",(0,t.jsx)(i.a,{href:"/docs/config_basics#generated-configuration",children:"SSR software documentation"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"Example (BGP over SVR):"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:'config\n\n    authority\n\n        service            _bgp_dc1_loopback1\n            name                     _bgp_dc1_loopback1\n            description              "Auto generated BGP Service for dc1 at 172.20.0.1"\n            enabled                  true\n            scope                    private\n            security                 internal\n            tap-multiplexing         false\n\n            transport                tcp\n                protocol    tcp\n\n                port-range  179\n                    start-port  179\n                    end-port    179\n                exit\n            exit\n            address                  172.20.0.1/32\n            access-policy-generated  false\n\n            access-policy            _bgp_speaker_\n                source      _bgp_speaker_\n                permission  allow\n            exit\n            service-policy           MPLS-DIA-LTE\n            share-service-routes     false\n            source-nat               network-interface\n            application-type         generic\n            generated                true\n        exit\n    exit\nexit\n'})}),"\n",(0,t.jsx)(i.h3,{id:"routerrouter-group-based-services",children:"Router/Router Group-Based Services"}),"\n",(0,t.jsx)(i.p,{children:"Router- and router group-based services are not services unto themselves; rather, the term refers to the capability of limiting the scope of services to specific routers or sets of routers. By default, any service configured on a conductor is pushed down to all routers it manages. This may result in unnecessary bloat on routers that will never have a calling for a specific service. E.g., in a typical retail deployment traffic generally goes in one of two directions: originating at a store and heading to a data center, or originating at a data center and heading to a store. Thus it is important for head end routers to have access to store services, and for a store to have the configuration corresponding to its own local services, but there will be no need for every store to have every other store's local services in a full mesh."}),"\n",(0,t.jsx)(i.admonition,{type:"note",children:(0,t.jsx)(i.p,{children:"In case a full mesh is a requirement, Juniper has the Summary and Spoke Services \u2013 which use router-based services to optimize the configuration."})}),"\n",(0,t.jsxs)(i.p,{children:["Use the ",(0,t.jsx)(i.code,{children:"applies-to"})," configuration within a ",(0,t.jsx)(i.code,{children:"service"})," to restrict its scope:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:'admin@labsystem1.fiedler# show config running authority service lo_burlington\n\nconfig\n\n    authority\n\n        service  lo_burlington\n            name           lo_burlington\n\n            applies-to     router\n                type         router\n                router-name  burlington\n                router-name  newton\n            exit\n            description    "burlington loopback"\n            scope          private\n            security       interfabric\n            address        172.31.0.2/32\n\n            access-policy  trusted\n                source  trusted\n            exit\n\n            access-policy  _internal_\n                source  _internal_\n            exit\n        exit\n    exit\nexit\n'})}),"\n",(0,t.jsxs)(i.p,{children:["In this example, the service will only be delivered to two routers: ",(0,t.jsx)(i.code,{children:"burlington"})," and ",(0,t.jsx)(i.code,{children:"newton"}),". When using the ",(0,t.jsx)(i.code,{children:"applies-to router-group"})," configuration, the group name is configured within each router."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"config\n\n    authority\n\n        service  core2store-default\n            name            core2store-default\n\n            applies-to      router-group\n                type        router-group\n                group-name  DC-routers\n                group-name  retail-routers\n            exit\n            enabled         true\n            scope           private\n            security        internal\n\n            transport       tcp\n                protocol  tcp\n            exit\n\n            transport       udp\n                protocol  udp\n            exit\n            address         10.0.0.0/8\n\n            access-policy   datacenter\n                source      datacenter\n                permission  allow\n            exit\n\n            service-policy  DIA-MPLS-LTE\n        exit\n    exit\nexit\n"})}),"\n",(0,t.jsxs)(i.p,{children:["Here's a common sight in large retail deployments: a ",(0,t.jsx)(i.code,{children:"core2store"})," service for traffic originating in the data center and destined for a retail store. It is applied to two router groups: ",(0,t.jsx)(i.code,{children:"DC-routers"})," and ",(0,t.jsx)(i.code,{children:"retail-routers"}),". By applying a ",(0,t.jsx)(i.code,{children:"group"})," tag on a managed router that matches either (or both) of these two group names, it will receive a copy of this configuration from the conductor."]}),"\n",(0,t.jsx)(i.h3,{id:"application-module-services",children:"Application-Module Services"}),"\n",(0,t.jsxs)(i.p,{children:["Application-module services are dynamic and have two parts: a ",(0,t.jsx)(i.code,{children:"service"})," configuration that references an ",(0,t.jsx)(i.code,{children:"application-name"}),", and a script resident on the SSR's host operating system with that ",(0,t.jsx)(i.code,{children:"application-name"})," that generates forwarding rules (FIB entries, in the form of JSON configuration) that are installed onto the SSR. Application-module services give the ultimate flexibility to the SSR administrator: the ability to  define the forwarding logic of the SSR using the programming language of their choice."]}),"\n",(0,t.jsxs)(i.p,{children:["To enable an application-module service, a router must have ",(0,t.jsx)(i.code,{children:"application-identification"})," with ",(0,t.jsx)(i.code,{children:"mode"})," set to ",(0,t.jsx)(i.code,{children:"module"}),", as is shown here:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"admin@labsystem1.fiedler# show config running auth router burlington application-identification\n\nconfig\n\n    authority\n\n        router  burlington\n            name                        burlington\n\n            application-identification\n                mode  module\n            exit\n        exit\n    exit\nexit\n"})}),"\n",(0,t.jsx)(i.p,{children:"A service that references a module name is configured like this:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:'admin@labsystem1.fiedler# show config running auth service custom-service\n\nconfig\n\n    authority\n\n        service  custom-service\n            name                  custom-service\n\n            description           "Custom service definition using Application Module"\n            scope                 private\n            application-name      customsvc\n\n            access-policy         _internal_\n                source      _internal_\n                permission  allow\n            exit\n\n            share-service-routes  false\n        exit\n    exit\nexit\n'})}),"\n",(0,t.jsxs)(i.p,{children:["Lastly, a file within ",(0,t.jsx)(i.code,{children:"/etc/128technology/application-modules/"})," to be executed by the SSR software:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"[pt@labsystem4 application-modules]$ cd /etc/128technology/application-modules/\n[pt@labsystem4 application-modules]$ ls -ltr\ntotal 12\nlrwxrwxrwx  1 root root   21 Sep  1  2018 office365.py -> defaults/office365.py\ndrwxr-xr-x  2 root root 4096 Jan 29 16:46 app_module_utils\ndrwxr-xr-x. 2 root root 4096 Jan 29 16:48 defaults\n-rwxr-xr-x  1 root root 1372 Feb 26 06:35 customsvc.py\n"})}),"\n",(0,t.jsxs)(i.p,{children:["Here we can see the python script ",(0,t.jsx)(i.code,{children:"customsvc.py"})," file, which matches the ",(0,t.jsx)(i.code,{children:"application-name"})," configured in the ",(0,t.jsx)(i.code,{children:"service"})," definition above. This is what creates the linkage between the service and the script."]}),"\n",(0,t.jsxs)(i.p,{children:["For more information on creating your own custom ",(0,t.jsx)(i.code,{children:"application-module"}),", review the documentation and browse the articles on Interchange."]}),"\n",(0,t.jsx)(i.h3,{id:"hierarchical-services",children:"Hierarchical Services"}),"\n",(0,t.jsxs)(i.p,{children:["Introduced in the 5.0 release, ",(0,t.jsx)(i.em,{children:"hierarchical services"})," allow you to create groupings of services that, like ",(0,t.jsx)(i.a,{href:"/docs/config_tenants#subtenant-hierarchies",children:"hierarchical tenants"}),", inherit properties from one another."]}),"\n",(0,t.jsxs)(i.p,{children:["From a configuration standpoint, hierarchical services follow the same convention that other, hierarchically organized data model elements do within the SSR software: by using a ",(0,t.jsx)(i.code,{children:"."}),' separator. They also follow the same principle of inheritance: "children" inherit the properties of the "parent."']}),"\n",(0,t.jsx)(i.p,{children:"By way of example, consider the following configuration fragment:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:'admin@labsystem1.fiedler# show config running authority service internet\n\nconfig\n    authority\n        service  internet\n            name                  internet\n            description           "public internet"\n            scope                 private\n            security              internal\n            address               0.0.0.0/0\n\n            access-policy         guest\n                source      guest\n                permission  allow\n            exit\n\n            access-policy         trusted\n                source      trusted\n                permission  allow\n            exit\n            service-policy        data-best-effort\n        exit\n    exit\nexit\n'})}),"\n",(0,t.jsxs)(i.p,{children:['This represents a standard, run of the mill "default route" service for basic internet traffic. Most deployments of the SSR software have something similar to this configured, along with the requisite ',(0,t.jsx)(i.code,{children:"service-route"})," configuration to accompany them. Now consider this:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:'admin@labsystem1.fiedler# show conf running authority service ZOOM.internet\n\nconfig\n    authority\n        service  ZOOM.internet\n            name                  ZOOM.internet\n            description           "Zoom video conferencing"\n\n            application-name      ZOOM\n\n            access-policy         guest\n                source      guest\n                permission  deny\n            exit\n\n            service-policy        voip-video\n            share-service-routes  false\n        exit\n    exit\nexit\n'})}),"\n",(0,t.jsxs)(i.p,{children:["Here is an example of a ",(0,t.jsx)(i.em,{children:"hierarchical service"}),", designed to carry Zoom video conferencing traffic. There are several notable elements to discuss."]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["The name contains a reference to a parent service. In our case, the parent is ",(0,t.jsx)(i.code,{children:"internet"}),". Thus it will ",(0,t.jsx)(i.strong,{children:"inherit"})," its properties, unless they are overridden. For instance, if we do not configure a specific ",(0,t.jsx)(i.code,{children:"service-route"})," for ",(0,t.jsx)(i.code,{children:"ZOOM.internet"}),", it will follow the same routes that ",(0,t.jsx)(i.code,{children:"internet"})," does. (This is a common use case, since there are typically only a handful of egress interfaces and/or peers to send traffic to.)"]}),"\n",(0,t.jsxs)(i.li,{children:["The ",(0,t.jsx)(i.code,{children:"access-policy"})," has been modified, and this one is blocks access by the ",(0,t.jsx)(i.code,{children:"guest"})," tenant. Note that when configuring ",(0,t.jsx)(i.code,{children:"access-policy"})," in a child tenant, it will always inherit the ",(0,t.jsx)(i.code,{children:"access-policy"})," statements from the parent."]}),"\n",(0,t.jsxs)(i.li,{children:["The ",(0,t.jsx)(i.code,{children:"service-policy"})," has been overridden. The parent tenant treats all traffic as ",(0,t.jsx)(i.code,{children:"data-best-effort"}),", but Zoom traffic will get much better treatment."]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["Hierarchical services are an excellent way to organize services to avoid a bloated configuration due to highly duplicated patterns of data. (E.g., all internet-based services will generally follow the same local breakout paths; by organizing them into a hierarchy you need to configure far fewer ",(0,t.jsx)(i.code,{children:"service-route"})," elements.)"]}),"\n",(0,t.jsx)(i.h4,{id:"inherited-attributes-of-hierarchical-services",children:"Inherited Attributes of Hierarchical Services"}),"\n",(0,t.jsx)(i.p,{children:"The following table lists the inheritable traits passed from a parent to child."}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Attribute"}),(0,t.jsx)(i.th,{children:"Notes"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"access-policy"}),(0,t.jsx)(i.td,{children:"Inherited. Can be augmented, but not overridden."})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"multicast-sender-policy"}),(0,t.jsx)(i.td,{children:"Inherited. Can be augmented, but not overridden."})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"security"}),(0,t.jsx)(i.td,{children:"Inherited. Can be overridden."})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"service-group"}),(0,t.jsx)(i.td,{children:"Inherited. Can be overridden."})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"service-policy"}),(0,t.jsx)(i.td,{children:"Inherited. Can be overridden."})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"transport"}),(0,t.jsx)(i.td,{children:"Inherted. Can be overriden."})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"applies-to"}),(0,t.jsx)(i.td,{children:"Inherited. Can be overridden. Note that a configuration is considered invalid if an orphan child exists on a router without its parent."})]})]})]}),"\n",(0,t.jsx)(i.h3,{id:"template-services",children:"Template Services"}),"\n",(0,t.jsxs)(i.p,{children:["Introduced in 5.0 along with hierarchical services, ",(0,t.jsx)(i.em,{children:"template services"})," represent a service that exists solely to contain inheritable elements by its children. Notably, it has no ",(0,t.jsx)(i.code,{children:"address"})," of its own \u2013 merely inheritable attributes. They exist to reduce configuration bloat due to repetition."]}),"\n",(0,t.jsxs)(i.p,{children:["Template services are characterized by an ",(0,t.jsx)(i.code,{children:"application-type"})," set to ",(0,t.jsx)(i.code,{children:"template"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"Consider the following configuration fragment:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"service           core\n    name             core\n    description      \u201cTemplate service for core traffic\u201d\n    application-type template\n    scope            private\n    security         internal\n    service-policy   data-best-effort\n    applies-to       headend\n    applies-to       branch\n\n    access-policy     lan\n        source         lan\n        permission     allow\n    exit\n    access-policy     wan\n        source         wan\n        permission     allow\n    exit\nexit\n\nservice           branch-to-he.core\n    name           branch-to-he.core\n    description    \u201cForward business traffic to headend\u201d\n    address        128.66.0.0/16\n    applies-to     branch\nexit\n\nservice           voice.core\n    name             voice.core\n    description      \u201cVoice traffic\u201d\n    address          128.66.1.0/24\n    service-policy   voip-audio\n    applies-to       headend\nexit\n\nservice           mgmt.core\n     name            mgmt.core\n     description     \u201cManagement traffic\u201d\n     address         128.66.2.0/24\n     applies-to      headend\nexit\n"})}),"\n",(0,t.jsxs)(i.p,{children:["In this example, the ",(0,t.jsx)(i.code,{children:"core"})," service exists to define the default ",(0,t.jsx)(i.code,{children:"scope"}),", ",(0,t.jsx)(i.code,{children:"security"}),", ",(0,t.jsx)(i.code,{children:"service-policy"}),", and ",(0,t.jsx)(i.code,{children:"access-policy"}),". The ",(0,t.jsx)(i.code,{children:"branch-to-he.core"})," service exists only on branch routers and acts as a summary service, pushing all relevant traffic to the headend. The child service ",(0,t.jsx)(i.code,{children:"voice.core"})," provides the appropriate address definitions for voice, as well as overriding the default ",(0,t.jsx)(i.code,{children:"service-policy"}),". The ",(0,t.jsx)(i.code,{children:"mgmt.core"})," child service provides the appropriate address definitions, but does not override the default service characteristics from ",(0,t.jsx)(i.code,{children:"core"}),"."]}),"\n",(0,t.jsx)(i.h2,{id:"service-policy",children:"Service Policy"}),"\n",(0,t.jsxs)(i.p,{children:["Each service can have a ",(0,t.jsx)(i.code,{children:"service-policy"})," associated with it, to govern its behavior through various configurable attributes. This can influence the service's path selection and behavior in the event of path failures or path impairments as ",(0,t.jsx)(i.em,{children:"administrative priorities"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["Here's a representative ",(0,t.jsx)(i.code,{children:"service-policy"}),", to provide context for discussion:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"service-policy  MPLS-DIA-LTE\n    name                 MPLS-DIA-LTE\n    vector               mpls\n        name      mpls\n        priority  5\n    exit\n\n    vector               broadband\n        name      broadband\n        priority  10\n    exit\n\n    vector               lte\n        name      lte\n        priority  15\n    exit\n\n    session-resiliency   revertible-failover\n    path-quality-filter  true\n    max-loss             1\n    max-latency          300\n    max-jitter           100\nexit\n"})}),"\n",(0,t.jsx)(i.p,{children:"There are three principal controls within this service-policy:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Vectors, which are used to indicate the administrative preference for path selection."}),"\n",(0,t.jsx)(i.li,{children:"A session-resiliency choice, used to indicate the desired behavior in the event of path failures."}),"\n",(0,t.jsx)(i.li,{children:"Path quality metrics, used to indicate the tolerance for loss, latency, and jitter on a path before it is declared ineligible for selection."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"vectors",children:"Vectors"}),"\n",(0,t.jsxs)(i.p,{children:["By configuring vectors and assigning ",(0,t.jsx)(i.code,{children:"priority"})," to them, an administrator can influence the path selection for egress traffic by an SSR device. Each vector has two components: a ",(0,t.jsx)(i.code,{children:"name"})," and a ",(0,t.jsx)(i.code,{children:"priority"}),". The ",(0,t.jsx)(i.code,{children:"name"})," listed is also applied to an adjacency (though typically configured within a ",(0,t.jsx)(i.code,{children:"neighborhood"})," and triggering the generation of a peer adjacency) to associate to the preferred egress path."]}),"\n",(0,t.jsx)(i.p,{children:"By way of example, here is an adjacency on the broadband interface of an example branch location:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"config\n\n    authority\n\n        router  site2020\n            name  site2020\n\n            node  node1\n                name              node1\n\n                device-interface  wan\n                    name               wan\n\n                    network-interface  wan1\n                        name       wan1\n\n                        adjacency  203.0.113.2 dc1\n                            ip-address             203.0.113.2\n                            peer                   dc1\n                            peer-connectivity      bidirectional\n                            generated              true\n                            inter-router-security  interrouter\n                            cost                   0\n                            qp-value               0\n                            vector                 broadband\n                        exit\n                    exit\n                exit\n            exit\n        exit\n    exit\nexit\n"})}),"\n",(0,t.jsxs)(i.p,{children:["In the configuration fragment, you can see that the broadband interface (named ",(0,t.jsx)(i.code,{children:"wan1"}),") has an adjacency configured to connect to its data center (named ",(0,t.jsx)(i.code,{children:"dc1"}),"). This adjacency uses the vector ",(0,t.jsx)(i.code,{children:"broadband"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["Consider the ",(0,t.jsx)(i.code,{children:"MPLS-DIA-LTE"})," service-policy shown above, which lists five vectors. For services leveraging this service-policy, the adjacency with the ",(0,t.jsx)(i.code,{children:"broadband"})," vector would be the second priority, behind adjacencies referencing ",(0,t.jsx)(i.code,{children:"mpls"})," \u2013 since that has a lower cost (higher priority)."]}),"\n",(0,t.jsx)(i.h3,{id:"session-resiliency",children:"Session Resiliency"}),"\n",(0,t.jsxs)(i.p,{children:["As shown in the ",(0,t.jsx)(i.code,{children:"MPLS-DIA-LTE"})," service-policy, the session-resiliency is set to ",(0,t.jsx)(i.code,{children:"revertible-failover"}),". This policy comes into play when traffic needs to move in the event of a failure to a transport circuit (either a path failure or a path quality threshold has been crossed). After a failure to a circuit, traffic using that path will migrate to the next best circuit. When that circuit's quality is restored (the path returns to the ",(0,t.jsx)(i.code,{children:"up"})," state, or the quality thresholds return to satisfactory values), ",(0,t.jsx)(i.code,{children:"revertible-failover"})," ",(0,t.jsx)(i.em,{children:"will migrate the traffic back to the preferred circuit"}),". Contrast this to the session-resiliency setting of ",(0,t.jsx)(i.code,{children:"failover"}),", which will persist the traffic on the migrated circuit and not return it to the preferred circuit."]}),"\n",(0,t.jsxs)(i.p,{children:["In general, Juniper recommends using the ",(0,t.jsx)(i.code,{children:"revertible-failover"})," setting for long-lived session types, such as SIP registrations. By contrast, Juniper recommends using the ",(0,t.jsx)(i.code,{children:"failover"})," setting for transient sessions (such as the audio associated with a telephone call)."]}),"\n",(0,t.jsx)(i.admonition,{type:"note",children:(0,t.jsx)(i.p,{children:"The vast majority of network sessions are transient, short-lived sessions, but you can validate this during your application discovery exercises."})}),"\n",(0,t.jsx)(i.h3,{id:"session-failover",children:"Session Failover"}),"\n",(0,t.jsx)(i.p,{children:"For long-lived sessions that are very reverse-data intensive (for example, a TCP session that is downloading a large file over HTTP) a session failover often results in an empty session. This happens because the new session is expecting a forward packet to re-establish the session. To prevent the transfer from stalling, a keep-alive mechanism has been added for flow moves. When a flow move is triggered, the SSR detects inactivity in forward traffic and generates a keep-alive packet in the forward direction. This packet causes the session to be properly modified to the new path, and forwarded on to the subsequent router(s). The subsequent router session is modified as well. The keep-alive packet is dropped before egressing to the LAN. In a case where the failover is selecting a new path to a new node/router rather than modifying an existing session, a new session will be created."}),"\n",(0,t.jsx)(i.h3,{id:"path-quality-metrics",children:"Path Quality Metrics"}),"\n",(0,t.jsx)(i.p,{children:"The SSR supports four path quality metrics in its service-policy, all of which establish thresholds for determining a path's eligibility for carrying traffic that references that service-policy. The metrics are:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"max-loss"}),", which will indicate the maximum percentage of packet loss before a path is ineligible"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"max-latency"}),", which indicates the maximum latency (half of the round trip time) before a path is unsuitable"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"max-jitter"}),", which indicates the maximum jitter before a path is unsuitable"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"min-mos"})," (not part of the example configuration), which indicates the minimum Mean Opinion Score before a path is considered unsuitable"]}),"\n"]}),"\n",(0,t.jsx)(i.admonition,{type:"info",children:(0,t.jsx)(i.p,{children:"The MOS value for a given path is a composite metric, computed based on loss, latency and jitter as its factors."})}),"\n",(0,t.jsx)(i.h3,{id:"transport-state-enforcement",children:"Transport State Enforcement"}),"\n",(0,t.jsxs)(i.p,{children:["Within the service-policy configuration is the ",(0,t.jsx)(i.a,{href:"/docs/config_reference_guide#service-policy",children:"transport-state-enforcement"})," parameter, which governs the behavior of the SSR's TCP state machine for processing inbound TCP packets. As a stateful networking device, the SSR's default behavior is to reject any mid-flow TCP packets (i.e., packets without the SYN flag set) unless it \u2013 or its paired node in a dual node HA router \u2013 participated in the TCP three-way handshake for that session. There are deployments where this behavior may be undesirable."]}),"\n",(0,t.jsxs)(i.p,{children:["For example, when an environment includes systems that are deployed in a ",(0,t.jsx)(i.a,{href:"/docs/config_dual_router_ha",children:(0,t.jsx)(i.em,{children:"dual router HA"})})," configuration, any services used to send traffic to or from the dual router HA must reference a service-policy that has ",(0,t.jsx)(i.code,{children:"transport-state-enforcement"})," set to ",(0,t.jsx)(i.code,{children:"allow"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["This is because the dual router HA deployment model specifically does not share information between the SSR instances comprising the HA pair; thus, a router may receive mid-flow TCP packets if its counterpart fails (or if routing converges to the other node for any reason, etc.). Without access to any shared state about the in-progress TCP session, if ",(0,t.jsx)(i.code,{children:"transport-state-enforcement"})," is left to its default value, this TCP session would get rejected by the router."]}),"\n",(0,t.jsxs)(i.p,{children:["It is also reasonable to consider ",(0,t.jsx)(i.code,{children:"transport-state-enforcement"}),' for SSR instances deployed as transit routers. That is, when a router \u2013 even one deployed as a dual node HA pair \u2013 could receive traffic in the event of a failure somewhere else in the network. Consider a case where a branch office has two possible data centers it could leverage when sending traffic; if the primary data center becomes unreachable, then traffic may flow to the alternate data center, including packets associated with existing TCP sessions. Generally, for catastrophic failures such as disaster recovery sites, it is not unreasonable to expect that the network will "hang up" on existing TCP sessions to instigate a reconnection attempt by the client. (In fact, it often turns out to be ',(0,t.jsx)(i.em,{children:"beneficial"})," to have the client(s) reconnect, to ensure consistency with application delivery, DPI, etc. at the new data center.)"]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>a});var t=n(96540);const r={},s=t.createContext(r);function o(e){const i=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);