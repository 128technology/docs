"use strict";(self.webpackChunk_128t_docs=self.webpackChunk_128t_docs||[]).push([[6863],{85621:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var o=t(74848),s=t(28453);const i={title:"Connecting to Routers from a Conductor",sidebar_label:"Connecting to Routers"},r=void 0,a={id:"ts_connecting_to_routers",title:"Connecting to Routers from a Conductor",description:"The connect command affords administrators the ability to connect to any managed SSR node via the PCLI from the conductor. This is implemented as a reverse SSH tunnel, originated by the SSR, and associated with a specific loopback address and port on the conductor. (The loopback address for all managed routers is 127.127.0.1, and the port is unique per router.)",source:"@site/docs/ts_connecting_to_routers.md",sourceDirName:".",slug:"/ts_connecting_to_routers",permalink:"/docs/ts_connecting_to_routers",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1710456059,formattedLastUpdatedAt:"Mar 14, 2024",frontMatter:{title:"Connecting to Routers from a Conductor",sidebar_label:"Connecting to Routers"},sidebar:"docs",previous:{title:"CPU Spikes",permalink:"/docs/ts_cpu_spikes"},next:{title:"Forwarding Plane Resource Pools",permalink:"/docs/ts_forwarding_resource_pools"}},c={},d=[{value:"The nodeIdentifier File Contents",id:"the-nodeidentifier-file-contents",level:2},{value:"Connecting to a Managed Node",id:"connecting-to-a-managed-node",level:2},{value:"Using Other SSH-based Applications",id:"using-other-ssh-based-applications",level:2}];function l(e){const n={code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"connect"})," command affords administrators the ability to connect to any managed SSR node via the PCLI from the conductor. This is implemented as a reverse SSH tunnel, originated by the SSR, and associated with a specific loopback address and port on the conductor. (The loopback address for all managed routers is ",(0,o.jsx)(n.code,{children:"127.127.0.1"}),", and the port is unique per router.)"]}),"\n",(0,o.jsx)(n.p,{children:"Information about the IP and port assignments is maintained by the conductor in the file located at:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"/var/lib/128technology/connect/nodeIdentifier\n"})}),"\n",(0,o.jsxs)(n.p,{children:["As new SSR nodes (the fundamental building block of an SSR) are added to or removed from an Authority, this ",(0,o.jsx)(n.code,{children:"nodeIdentifier"})," file will get rotated in the same way that log files get rotated. Thus, you may see many iterations of this file on your filesystem. The newest will always be the copy without any suffix appended to it, as indicated above."]}),"\n",(0,o.jsx)(n.h2,{id:"the-nodeidentifier-file-contents",children:"The nodeIdentifier File Contents"}),"\n",(0,o.jsxs)(n.p,{children:["Because the ",(0,o.jsx)(n.code,{children:"connect"})," command uses SSH, the ",(0,o.jsx)(n.code,{children:"nodeIdentifier"})," file is written in the format of a SSH configuration file. Here is an excerpt from one sample system:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"[t128@conductor ~]$ cat /var/lib/128technology/connect/nodeIdentifier\nHost node1.router1\n    Port 16496\n    HostName 127.127.0.1\n\nHost node2.router1\n    Port 16497\n    HostName 127.127.0.1\n\nHost node1.router2\n    Port 16498\n    HostName 127.127.0.1\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Each node for each router is represented as a separate ",(0,o.jsx)(n.code,{children:"Host"})," statement, and is written in the form ",(0,o.jsx)(n.code,{children:"node-name.router-name"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"connecting-to-a-managed-node",children:"Connecting to a Managed Node"}),"\n",(0,o.jsxs)(n.p,{children:["While the PCLI gives administrators the ability to connect to managed nodes using its packaged ",(0,o.jsx)(n.code,{children:"connect"})," command, the implementation also gives you the flexibility to use the same reverse SSH tunnels manually within Linux via the ",(0,o.jsx)(n.code,{children:"connect128t"})," command."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"[t128@conductor ~]$ connect128t --router router1 --node node1\nt128@127.127.0.1's password: \u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\nLast login: Wed Jan 16 23:07:45 2019 from 10.128.0.1\n[t128@node1 ~]$ \n"})}),"\n",(0,o.jsx)(n.h2,{id:"using-other-ssh-based-applications",children:"Using Other SSH-based Applications"}),"\n",(0,o.jsxs)(n.p,{children:["Various other applications have been built using SSH, and can leverage the same techniques described above to perform remote actions on managed nodes. Namely ",(0,o.jsx)(n.code,{children:"scp"})," (which is a derivative of BSD's ",(0,o.jsx)(n.em,{children:"rcp"})," utility, but built on top of SSH) for copying files, and ",(0,o.jsx)(n.code,{children:"sftp"})," (which is loosely based on FTP, and also built on top of SSH) for an interactive file transfer session."]}),"\n",(0,o.jsxs)(n.p,{children:["These two applications (",(0,o.jsx)(n.code,{children:"scp"})," and ",(0,o.jsx)(n.code,{children:"sftp"}),") in particular are extremely useful for copying files to and from remote devices within the Linux shell. As we demonstrated with SSH above, we can use the reverse SSH tunnel to connect to managed nodes either by port reference, or by alias reference when using the configuration in the ",(0,o.jsx)(n.code,{children:"nodeIdentifier"})," file."]}),"\n",(0,o.jsx)(n.p,{children:"For example, assume I have a PCAP file on a managed node and I want to copy that to my conductor so I can later pull it down to my desktop for analysis. This can be done as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"[t128@conductor ~]$ scp -F /var/lib/128technology/connect/nodeIdentifier t128@node1.router1:/var/log/128technology/128T_wan.pcap /tmp\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Just as with SSH, we can pass the ",(0,o.jsx)(n.code,{children:"nodeIdentifier"})," file using ",(0,o.jsx)(n.code,{children:"-F"})," as an argument to ",(0,o.jsx)(n.code,{children:"scp"}),". This command will copy the ",(0,o.jsx)(n.code,{children:"128T_wan.pcap"})," file from the SSR's log directory to the conductor's filesystem in /tmp."]}),"\n",(0,o.jsxs)(n.p,{children:["Here's another example, using ",(0,o.jsx)(n.code,{children:"sftp"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"[t128@conductor ~]$ sftp -F /var/lib/128technology/connect/nodeIdentifier t128@node1.router1\nt128@127.127.0.1's password: \u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\nConnected to node1.router1.\nsftp>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Now we can interactively transfer many files to or from the remote node within the ",(0,o.jsx)(n.code,{children:"sftp"})," application."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(96540);const s={},i=o.createContext(s);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);